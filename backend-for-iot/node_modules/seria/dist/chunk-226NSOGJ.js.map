{"version":3,"sources":["../src/json/parse.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { createChannel, type Sender } from \"../channel\";\r\nimport { deferredPromise, type DeferredPromise } from \"../deferredPromise\";\r\nimport { Tag, isTypedArrayTag } from \"../tag\";\r\nimport {\r\n  isTrackingAsyncIterable,\r\n  trackAsyncIterable,\r\n} from \"../trackingAsyncIterable\";\r\nimport { isTrackingPromise, trackPromise } from \"../trackingPromise\";\r\nimport { base64ToBuffer, isPlainObject } from \"../utils\";\r\n\r\ntype Context = {\r\n  references: readonly unknown[];\r\n};\r\n\r\n/**\r\n * A function that convert a value.\r\n */\r\nexport type Reviver = (value: any) => any | undefined;\r\n\r\n/**\r\n * Parse a `json` string to a value.\r\n * @param value The `json` value to parse.\r\n * @param reviver A function to convert a value.\r\n * @returns The parsed value.\r\n */\r\nexport function parse(value: string, reviver?: Reviver): unknown {\r\n  const result = internal_parseValue(value, { reviver });\r\n  return result.data;\r\n}\r\n\r\n/**\r\n * Takes a stream and parse each value until it resolves.\r\n * @param stream The stream to parse.\r\n * @param reviver A function to convert a value.\r\n * @returns A promise that resolve to the parsed value.\r\n */\r\nexport async function parseFromStream(\r\n  stream: ReadableStream<string>,\r\n  reviver?: Reviver\r\n) {\r\n  const reader = internal_parseFromStream(stream, reviver).getReader();\r\n  let resolved = false;\r\n  const deferred = deferredPromise();\r\n\r\n  void Promise.resolve().then(async () => {\r\n    const promises: Promise<any>[] = [];\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      const { done, value } = await reader.read();\r\n      if (done || value === undefined) {\r\n        break;\r\n      }\r\n\r\n      if (!resolved) {\r\n        resolved = true;\r\n        deferred.resolve(value);\r\n      }\r\n\r\n      if (value instanceof Promise) {\r\n        promises.push(value);\r\n      }\r\n    }\r\n\r\n    if (!resolved) {\r\n      deferred.reject(new Error(\"Unable to find resolved value\"));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n  });\r\n\r\n  return deferred.promise;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function internal_parseFromStream(\r\n  stream: ReadableStream<string>,\r\n  reviver?: Reviver\r\n) {\r\n  const promisesMap = new Map<number, DeferredPromise<unknown>>();\r\n  const channelsMap = new Map<number, Sender<unknown>>();\r\n  const reader = stream.getReader();\r\n\r\n  return new ReadableStream<unknown>({\r\n    async start(controller) {\r\n      async function processChunk(jsonChunk: string) {\r\n        const { data, pendingPromises, pendingChannels } = internal_parseValue(\r\n          jsonChunk,\r\n          {\r\n            deferPromises: true,\r\n            reviver,\r\n          }\r\n        );\r\n\r\n        // Send the value\r\n        controller.enqueue(data);\r\n\r\n        // Handle promises\r\n        {\r\n          for (const [id, deferred] of pendingPromises.entries()) {\r\n            promisesMap.set(id, deferred);\r\n          }\r\n\r\n          // Resolve a pending promise\r\n          if (isTrackingPromise(data)) {\r\n            const deferred = promisesMap.get(data.id);\r\n\r\n            if (!deferred) {\r\n              throw new Error(`Promise with id: '${data.id}' was not found`);\r\n            }\r\n\r\n            try {\r\n              const returnValue = await data;\r\n              deferred.resolve(returnValue);\r\n            } catch (err) {\r\n              deferred.reject(err);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Handle async iterators\r\n        {\r\n          if (pendingChannels.size > 0) {\r\n            for (const [id, channelSender] of pendingChannels.entries()) {\r\n              channelsMap.set(id, channelSender);\r\n            }\r\n          }\r\n\r\n          if (isTrackingAsyncIterable(data)) {\r\n            const sender = channelsMap.get(data.id);\r\n\r\n            if (!sender) {\r\n              throw new Error(\r\n                `AsyncIterator sender with id '${data.id}' was not found`\r\n              );\r\n            }\r\n\r\n            const isDone = data.context === \"done\";\r\n            for await (const item of data) {\r\n              sender.send(item);\r\n            }\r\n\r\n            if (isDone) {\r\n              sender.close();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      while (true) {\r\n        const { done, value: raw } = await reader.read();\r\n        if (done || raw === undefined) {\r\n          break;\r\n        }\r\n\r\n        const chunks = raw.split(\"\\n\\n\").filter(Boolean);\r\n\r\n        // We process all chunks at once if possible\r\n        if (chunks.length > 1) {\r\n          const promises = chunks.map(processChunk);\r\n          await Promise.all(promises);\r\n        } else {\r\n          await processChunk(chunks[0]);\r\n        }\r\n      }\r\n\r\n      controller.close();\r\n    },\r\n  });\r\n}\r\n\r\ntype Options = {\r\n  deferPromises?: boolean;\r\n  reviver?: Reviver;\r\n};\r\n\r\nfunction internal_parseValue(value: string, opts?: Options) {\r\n  const { deferPromises = false, reviver } = opts || {};\r\n  const pendingPromises = new Map<number, DeferredPromise<unknown>>();\r\n  const pendingChannels = new Map<number, Sender<unknown>>();\r\n\r\n  const { references, base } = (function () {\r\n    try {\r\n      const references = JSON.parse(value) as readonly unknown[];\r\n      return { references, base: references[0] };\r\n    } catch {\r\n      throw new Error(`Failed to parse base value: ${value}`);\r\n    }\r\n  })();\r\n\r\n  const deserizalizeValue = (input: any): unknown => {\r\n    if (reviver) {\r\n      const ret = reviver(input);\r\n      if (ret !== undefined) {\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    switch (typeof input) {\r\n      case \"number\":\r\n        return input;\r\n      case \"boolean\":\r\n        return input;\r\n      case \"string\": {\r\n        if (input[0] === \"$\") {\r\n          const maybeTag = input.slice(1);\r\n\r\n          switch (true) {\r\n            case maybeTag[0] === Tag.String: {\r\n              return input.slice(2);\r\n            }\r\n            case maybeTag[0] === Tag.Symbol: {\r\n              return Symbol.for(input.slice(2));\r\n            }\r\n            case maybeTag[0] === Tag.Date: {\r\n              return new Date(input.slice(2));\r\n            }\r\n            case maybeTag[0] === Tag.BigInt: {\r\n              return BigInt(input.slice(2));\r\n            }\r\n            case maybeTag === Tag.Undefined: {\r\n              return undefined;\r\n            }\r\n            case maybeTag === Tag.Infinity_: {\r\n              return Infinity;\r\n            }\r\n            case maybeTag === Tag.NegativeInfinity: {\r\n              return -Infinity;\r\n            }\r\n            case maybeTag === Tag.NegativeZero: {\r\n              return -0;\r\n            }\r\n            case maybeTag === Tag.NaN_: {\r\n              return NaN;\r\n            }\r\n            case maybeTag[0] === Tag.Set: {\r\n              const id = parseTagId(input.slice(2));\r\n              const set = new Set<any>();\r\n\r\n              try {\r\n                const values = references[id];\r\n                if (values) {\r\n                  if (Array.isArray(values)) {\r\n                    for (const item of values) {\r\n                      set.add(deserizalizeValue(item));\r\n                    }\r\n                  }\r\n                }\r\n              } catch (err) {\r\n                // failed to parse\r\n                console.error(err);\r\n              }\r\n\r\n              return set;\r\n            }\r\n            case maybeTag[0] === Tag.Map: {\r\n              const id = parseTagId(input.slice(2));\r\n              const map = new Map<any, any>();\r\n\r\n              try {\r\n                const values = references[id];\r\n                if (values) {\r\n                  if (Array.isArray(values)) {\r\n                    for (const [key, value] of values) {\r\n                      const decodedKey = deserizalizeValue(key);\r\n                      const decodedValue = deserizalizeValue(value);\r\n                      map.set(decodedKey, decodedValue);\r\n                    }\r\n                  }\r\n                }\r\n              } catch (err) {\r\n                // failed to parse\r\n                console.error(err);\r\n              }\r\n\r\n              return map;\r\n            }\r\n            case maybeTag[0] === Tag.Promise: {\r\n              const id = parseTagId(input.slice(2));\r\n              const rawValue = references[id];\r\n\r\n              if (rawValue === undefined) {\r\n                if (deferPromises) {\r\n                  const deferred = deferredPromise();\r\n                  pendingPromises.set(id, deferred);\r\n                  return deferred.promise;\r\n                }\r\n\r\n                throw new Error(\"Failed to find promise resolved value\");\r\n              }\r\n\r\n              try {\r\n                const resolvedValue = deserizalizeValue(rawValue);\r\n                return trackPromise(id, Promise.resolve(resolvedValue));\r\n              } catch {\r\n                throw new Error(\"Unable to resolve promise value\");\r\n              }\r\n            }\r\n            case maybeTag[0] === Tag.AsyncIterator: {\r\n              const id = parseTagId(input.slice(2));\r\n              const asyncIteratorValues = references[id];\r\n\r\n              if (!asyncIteratorValues) {\r\n                const [sender, receiver] = createChannel({ id });\r\n                pendingChannels.set(id, sender);\r\n                return receiver;\r\n              }\r\n\r\n              if (Array.isArray(asyncIteratorValues)) {\r\n                const length = asyncIteratorValues.length - 1;\r\n                const isDone = asyncIteratorValues[length] === \"done\";\r\n\r\n                const values = isDone\r\n                  ? asyncIteratorValues.slice(0, -1)\r\n                  : asyncIteratorValues;\r\n\r\n                const generator = (async function* () {\r\n                  for (const item of values) {\r\n                    const resolvedValue = deserizalizeValue(item);\r\n                    yield resolvedValue;\r\n                  }\r\n                })();\r\n\r\n                const trackedAsyncIterator = trackAsyncIterable(\r\n                  id,\r\n                  generator,\r\n                  isDone ? \"done\" : undefined\r\n                );\r\n\r\n                return trackedAsyncIterator;\r\n              } else {\r\n                throw new Error(\r\n                  \"Failed to parse async iterator, expected array of values\"\r\n                );\r\n              }\r\n            }\r\n            case isTypedArrayTag(maybeTag[0]): {\r\n              return deserializeBuffer(maybeTag[0], input, {\r\n                references,\r\n              });\r\n            }\r\n            default:\r\n              throw new Error(`Unknown reference value: ${input}`);\r\n          }\r\n        } else {\r\n          throw new Error(`Invalid reference value: ${input}`);\r\n        }\r\n      }\r\n      case \"object\": {\r\n        if (input === null) {\r\n          return null;\r\n        } else if (Array.isArray(input)) {\r\n          const arr: any[] = [];\r\n          for (const item of input) {\r\n            arr.push(deserizalizeValue(item));\r\n          }\r\n          return arr;\r\n        } else if (isPlainObject(input)) {\r\n          const obj: Record<string, unknown> = {};\r\n\r\n          for (const [key, value] of Object.entries(input)) {\r\n            obj[key] = deserizalizeValue(value);\r\n          }\r\n\r\n          return obj;\r\n        } else {\r\n          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);\r\n        }\r\n      }\r\n      default:\r\n        throw new Error(`Invalid value: ${input}`);\r\n    }\r\n  };\r\n\r\n  const data = deserizalizeValue(base);\r\n  return { data, pendingPromises, pendingChannels };\r\n}\r\n\r\nfunction deserializeBuffer(tag: Tag, input: string, context: Context) {\r\n  const getBufferData = () => {\r\n    const id = parseTagId(input.slice(2));\r\n    const data = context.references[id];\r\n    if (!data) {\r\n      throw new Error(`Unable to get '${input}' buffer data`);\r\n    }\r\n    return String(data);\r\n  };\r\n\r\n  switch (tag) {\r\n    case Tag.ArrayBuffer: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return bytes.buffer;\r\n    }\r\n    case Tag.Int8Array:\r\n      return base64ToBuffer(getBufferData(), Int8Array);\r\n    case Tag.Uint8Array:\r\n      return base64ToBuffer(getBufferData(), Uint8Array);\r\n    case Tag.Uint8ClampedArray:\r\n      return base64ToBuffer(getBufferData(), Uint8ClampedArray);\r\n    case Tag.Int16Array:\r\n      return base64ToBuffer(getBufferData(), Int16Array);\r\n    case Tag.Uint16Array:\r\n      return base64ToBuffer(getBufferData(), Uint16Array);\r\n    case Tag.Int32Array:\r\n      return base64ToBuffer(getBufferData(), Int32Array);\r\n    case Tag.Uint32Array:\r\n      return base64ToBuffer(getBufferData(), Uint32Array);\r\n    case Tag.Float32Array:\r\n      return base64ToBuffer(getBufferData(), Float32Array);\r\n    case Tag.Float64Array:\r\n      return base64ToBuffer(getBufferData(), Float64Array);\r\n    case Tag.BigInt64Array: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new BigInt64Array(bytes.buffer);\r\n    }\r\n    case Tag.BigUint64Array: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new BigUint64Array(bytes.buffer);\r\n    }\r\n    case Tag.DataView: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new DataView(bytes.buffer);\r\n    }\r\n    default:\r\n      throw new Error(`Unknown typed array buffer: ${input}`);\r\n  }\r\n}\r\n\r\nfunction parseTagId(input: string) {\r\n  const id = parseInt(input);\r\n\r\n  if (!Number.isFinite(id) || Number.isNaN(id)) {\r\n    throw new Error(`Invalid tag id: '${input}'`);\r\n  }\r\n\r\n  return id;\r\n}\r\n"],"mappings":"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","names":["references","value"]}
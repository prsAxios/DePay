import { TrackingPromise } from '../trackingPromise.js';
import { TrackingAsyncIterable } from '../trackingAsyncIterable.js';

type SerializeContext = {
    output: unknown[];
    writtenValues: Map<number, unknown>;
    pendingPromisesMap: Map<number, TrackingPromise<any>>;
    pendingIteratorsMap: Map<number, TrackingAsyncIterable<any>>;
    space?: string | number;
    nextId: () => number;
    encodeValue: (input: any) => unknown;
    checkWrittenValues: () => void;
};
type Replacer = (value: any, context: SerializeContext) => string | undefined;
/**
 * Converts a value to a json string.
 * @param value The value to convert.
 * @param replacer A function that encode a custom value.
 * @param space Adds indentation, white space to the json values line-breaks.
 * @returns The json string.
 * @throws If the promise contains any promise. Use `stringifyAsync` or `stringifyToStream` to convert value with promises.
 */
declare function stringify(value: unknown, replacer?: Replacer | null, space?: number | string): string;
/**
 * Converts a value to a json string and resolve all its promises.
 * @param value The value to convert.
 * @param replacer A function that encode a custom value.
 * @param space Adds indentation, white space to the json values line-breaks.
 * @returns The json string.
 */
declare function stringifyAsync(value: unknown, replacer?: Replacer | null, space?: number | string): Promise<string>;
/**
 * Convert a value to a `ReadableStream` that stringify each value.
 * @param value The value to convert.
 * @param replacer A function that encode a custom value.
 * @param space Adds indentation, white space to the json values line-breaks.
 * @returns A stream that stringify each value.
 */
declare function stringifyToStream(value: unknown, replacer?: Replacer | null, space?: number | string): ReadableStream<string>;

export { type Replacer, stringify, stringifyAsync, stringifyToStream };

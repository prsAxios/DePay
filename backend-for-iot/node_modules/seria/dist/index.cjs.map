{"version":3,"sources":["../src/index.ts","../src/trackingPromise.ts","../src/utils.ts","../src/tag.ts","../src/trackingAsyncIterable.ts","../src/json/stringify.ts","../src/channel.ts","../src/deferredPromise.ts","../src/json/parse.ts"],"sourcesContent":["import {\r\n  stringify,\r\n  stringifyToStream,\r\n  stringifyAsync,\r\n} from \"./json/stringify\";\r\n\r\nimport { parse, parseFromStream } from \"./json/parse\";\r\n\r\nexport {\r\n  stringify,\r\n  stringifyToStream,\r\n  stringifyAsync as stringifyAsync,\r\n  parse,\r\n  parseFromStream,\r\n};\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst TRACKING_PROMISE_SYMBOL = Symbol(\"TRACKING_PROMISE_SYMBOL\");\r\n\r\ntype PromiseStatus<T> =\r\n  | { state: \"pending\" }\r\n  | { state: \"resolved\"; data: T }\r\n  | { state: \"rejected\"; error: unknown };\r\n\r\nexport type TrackingPromise<T> = Promise<T> & {\r\n  id: number;\r\n  status: PromiseStatus<T>;\r\n  [TRACKING_PROMISE_SYMBOL]: true;\r\n};\r\n\r\nexport function trackPromise<T>(\r\n  id: number,\r\n  promise: Promise<T>\r\n): TrackingPromise<T> {\r\n  const tracking = Object.assign(promise, {\r\n    id,\r\n    status: { state: \"pending\" },\r\n    [TRACKING_PROMISE_SYMBOL]: true,\r\n  }) as TrackingPromise<T>;\r\n\r\n  tracking\r\n    .then((data) => {\r\n      tracking.status = {\r\n        state: \"resolved\",\r\n        data,\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      tracking.status = {\r\n        state: \"rejected\",\r\n        error,\r\n      };\r\n    });\r\n\r\n  return tracking;\r\n}\r\n\r\nexport function isTrackingPromise(\r\n  value: any\r\n): value is TrackingPromise<unknown> {\r\n  return (\r\n    value != null &&\r\n    typeof value.id === \"number\" &&\r\n    typeof value.status === \"object\" &&\r\n    value[TRACKING_PROMISE_SYMBOL] === true &&\r\n    value instanceof Promise\r\n  );\r\n}\r\n\r\nexport async function forEachPromise<T = unknown>(\r\n  promises: TrackingPromise<T>[],\r\n  callbacks: {\r\n    onResolved: (state: { data: T; id: number }) => void;\r\n    onRejected?: (state: { error: unknown; id: number }) => void;\r\n  }\r\n) {\r\n  const { onResolved, onRejected } = callbacks;\r\n  const pendingPromises: Promise<void>[] = [];\r\n\r\n  for (const p of promises) {\r\n    let resolving = p.then((data) => {\r\n      onResolved({ id: p.id, data });\r\n    });\r\n\r\n    if (onRejected) {\r\n      resolving = resolving.catch((error) => {\r\n        onRejected({ id: p.id, error });\r\n      });\r\n    }\r\n\r\n    pendingPromises.push(resolving);\r\n  }\r\n\r\n  await Promise.all(pendingPromises);\r\n}\r\n","// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js\r\nexport function isPlainObject(value: unknown) {\r\n  if (typeof value !== \"object\" || value === null) {\r\n    return false;\r\n  }\r\n\r\n  const prototype = Object.getPrototypeOf(value);\r\n  return (\r\n    (prototype === null ||\r\n      prototype === Object.prototype ||\r\n      Object.getPrototypeOf(prototype) === null) &&\r\n    !(Symbol.toStringTag in value) &&\r\n    !(Symbol.iterator in value)\r\n  );\r\n}\r\n\r\nexport function bufferToBase64(buffer: ArrayBuffer) {\r\n  let binary = \"\";\r\n  const bytes = new Uint8Array(buffer);\r\n  for (let i = 0; i < bytes.byteLength; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n\r\n  return btoa(binary);\r\n}\r\n\r\ninterface TypedArrayLike extends ArrayBufferView {\r\n  [index: number]: number;\r\n}\r\n\r\nexport function base64ToBuffer<T extends TypedArrayLike>(\r\n  base64String: string,\r\n  Constructor: new (buffer: ArrayBuffer) => T\r\n): T {\r\n  const binaryString = atob(base64String);\r\n  const bytes = new Uint8Array(binaryString.length);\r\n\r\n  for (let i = 0; i < binaryString.length; i++) {\r\n    bytes[i] = binaryString.charCodeAt(i);\r\n  }\r\n\r\n  return new Constructor(bytes.buffer);\r\n}\r\n\r\nexport const delay = (ms: number) =>\r\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\r\n","\r\n// We are using a format similar to the used in the react source code,\r\n// the problem is that using more than 1 character may introduce unintended collisions if handle incorrectly,\r\n// for example: $NaN and $N could case an error if handle incorrectly during deserialization.\r\n// We may need to keep only 1 character in the future to be consistent and prevent collisions easily,\r\n// or  get a better mechanism to handle collitions on the first character.\r\n\r\nexport const enum Tag {\r\n  String = \"$\",\r\n  Date = \"D\",\r\n  BigInt = \"n\",\r\n  FormData = \"K\",\r\n  Promise = \"@\",\r\n  Symbol = \"S\",\r\n  Set = \"W\",\r\n  Map = \"Q\",\r\n  Undefined = \"undefined\",\r\n  Infinity_ = \"Infinity\",\r\n  NegativeInfinity = \"-Infinity\",\r\n  NegativeZero = \"-0\",\r\n  NaN_ = \"NaN\",\r\n\r\n  // Others\r\n  File = \"k\",\r\n  AsyncIterator = \"#\",\r\n\r\n  // Buffers\r\n  ArrayBuffer = \"A\",\r\n  Int8Array = \"C\",\r\n  Uint8Array = \"c\",\r\n  Uint8ClampedArray = \"U\",\r\n  Int16Array = \"P\",\r\n  Uint16Array = \"p\",\r\n  Int32Array = \"L\",\r\n  Uint32Array = \"l\",\r\n  Float32Array = \"F\",\r\n  Float64Array = \"d\",\r\n  BigInt64Array = \"N\",\r\n  BigUint64Array = \"m\",\r\n  DataView = \"V\",\r\n}\r\n\r\nconst TYPED_ARRAY_TAGS = [\r\n  Tag.ArrayBuffer,\r\n  Tag.Int8Array,\r\n  Tag.Uint8Array,\r\n  Tag.Uint8ClampedArray,\r\n  Tag.Int16Array,\r\n  Tag.Uint16Array,\r\n  Tag.Int32Array,\r\n  Tag.Uint32Array,\r\n  Tag.Float32Array,\r\n  Tag.Float64Array,\r\n  Tag.BigInt64Array,\r\n  Tag.BigUint64Array,\r\n  Tag.DataView,\r\n];\r\n\r\nexport function isTypedArrayTag(tag: string): tag is Tag {\r\n  return TYPED_ARRAY_TAGS.includes(tag as Tag);\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst TRACKING_ASYNC_ITERABLE_SYMBOL = Symbol(\"TRACKING_ASYNC_ITERABLE_SYMBOL\");\r\n\r\nexport type TrackingAsyncIterable<T, TContext = unknown> = AsyncIterable<T> & {\r\n  id: number;\r\n  context?: TContext;\r\n  [TRACKING_ASYNC_ITERABLE_SYMBOL]: true;\r\n};\r\n\r\nexport function trackAsyncIterable<T, TContext = unknown>(\r\n  id: number,\r\n  asyncIterator: AsyncIterable<T>,\r\n  context?: TContext\r\n): TrackingAsyncIterable<T> {\r\n  return Object.assign(asyncIterator, {\r\n    id,\r\n    context,\r\n    [TRACKING_ASYNC_ITERABLE_SYMBOL]: true as const,\r\n  });\r\n}\r\n\r\nexport function isTrackingAsyncIterable(\r\n  value: any\r\n): value is TrackingAsyncIterable<unknown> {\r\n  return (\r\n    value != null &&\r\n    typeof value.id === \"number\" &&\r\n    typeof value[Symbol.asyncIterator] === \"function\" &&\r\n    value[TRACKING_ASYNC_ITERABLE_SYMBOL] === true\r\n  );\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport {\r\n  type TrackingPromise,\r\n  trackPromise,\r\n  forEachPromise,\r\n} from \"../trackingPromise\";\r\nimport { bufferToBase64, isPlainObject } from \"../utils\";\r\nimport { Tag } from \"../tag\";\r\nimport {\r\n  trackAsyncIterable,\r\n  type TrackingAsyncIterable,\r\n} from \"../trackingAsyncIterable\";\r\n\r\ntype SerializeContext = {\r\n  output: unknown[];\r\n  writtenValues: Map<number, unknown>;\r\n  pendingPromisesMap: Map<number, TrackingPromise<any>>;\r\n  pendingIteratorsMap: Map<number, TrackingAsyncIterable<any>>;\r\n  space?: string | number;\r\n  nextId: () => number;\r\n  encodeValue: (input: any) => unknown;\r\n  checkWrittenValues: () => void;\r\n};\r\n\r\nexport type Replacer = (\r\n  value: any,\r\n  context: SerializeContext\r\n) => string | undefined;\r\n\r\n/**\r\n * Converts a value to a json string.\r\n * @param value The value to convert.\r\n * @param replacer A function that encode a custom value.\r\n * @param space Adds indentation, white space to the json values line-breaks.\r\n * @returns The json string.\r\n * @throws If the promise contains any promise. Use `stringifyAsync` or `stringifyToStream` to convert value with promises.\r\n */\r\nexport function stringify(\r\n  value: unknown,\r\n  replacer?: Replacer | null,\r\n  space?: number | string\r\n) {\r\n  const { output, pendingPromises, pendingIterators } = internal_serialize(\r\n    value,\r\n    {\r\n      replacer,\r\n      space,\r\n    }\r\n  );\r\n\r\n  if (pendingPromises.length > 0) {\r\n    throw new Error(\"Serialiation result have pending promises\");\r\n  }\r\n\r\n  if (pendingIterators.length > 0) {\r\n    throw new Error(\"Serialiation result have pending async iterators\");\r\n  }\r\n\r\n  return JSON.stringify(output, null, space);\r\n}\r\n\r\n/**\r\n * Converts a value to a json string and resolve all its promises.\r\n * @param value The value to convert.\r\n * @param replacer A function that encode a custom value.\r\n * @param space Adds indentation, white space to the json values line-breaks.\r\n * @returns The json string.\r\n */\r\nexport async function stringifyAsync(\r\n  value: unknown,\r\n  replacer?: Replacer | null,\r\n  space?: number | string\r\n) {\r\n  const result = internal_serialize(value, {\r\n    replacer,\r\n    space,\r\n  });\r\n\r\n  // We need to resolve promises first in case any return an async iterator\r\n  await Promise.all(result.pendingPromises);\r\n\r\n  // Then we drain all the values on the async iterators\r\n  const iteratorPromises = result.pendingIterators.map(async (gen) => {\r\n    for await (const _ of gen) {\r\n      // nothing\r\n    }\r\n  });\r\n\r\n  await Promise.all(iteratorPromises);\r\n  return JSON.stringify(result.output, null, space);\r\n}\r\n\r\n/**\r\n * Convert a value to a `ReadableStream` that stringify each value.\r\n * @param value The value to convert.\r\n * @param replacer A function that encode a custom value.\r\n * @param space Adds indentation, white space to the json values line-breaks.\r\n * @returns A stream that stringify each value.\r\n */\r\nexport function stringifyToStream(\r\n  value: unknown,\r\n  replacer?: Replacer | null,\r\n  space?: number | string\r\n) {\r\n  const result = internal_serialize(value, {\r\n    replacer,\r\n    space,\r\n  });\r\n\r\n  return new ReadableStream<string>({\r\n    async start(controller) {\r\n      const json = JSON.stringify(result.output, null, space);\r\n      const pendingIteratorsMap = new Map<\r\n        number,\r\n        TrackingAsyncIterable<unknown>\r\n      >();\r\n      controller.enqueue(`${json}\\n\\n`);\r\n\r\n      await forEachPromise(result.pendingPromises, {\r\n        async onResolved({ data, id }) {\r\n          const resolved = trackPromise(id, Promise.resolve(data));\r\n\r\n          // `stringifyAsync` with an initial `id`\r\n          // We use the initial to set the promise on the correct slot\r\n          const serializedPromise = internal_serialize(resolved, {\r\n            replacer,\r\n            initialID: id,\r\n          });\r\n\r\n          await Promise.all(serializedPromise.pendingPromises);\r\n          const promiseJson = JSON.stringify(\r\n            serializedPromise.output,\r\n            null,\r\n            space\r\n          );\r\n\r\n          if (serializedPromise.pendingIterators.length > 0) {\r\n            for (const gen of serializedPromise.pendingIterators) {\r\n              pendingIteratorsMap.set(gen.id, gen);\r\n            }\r\n          }\r\n\r\n          controller.enqueue(`${promiseJson}\\n\\n`);\r\n        },\r\n      });\r\n\r\n      if (result.pendingIterators.length > 0) {\r\n        for (const gen of result.pendingIterators) {\r\n          pendingIteratorsMap.set(gen.id, gen);\r\n        }\r\n      }\r\n\r\n      const pendingIterators = Array.from(pendingIteratorsMap.values());\r\n\r\n      const resolveIterators = pendingIterators.map(async (iter) => {\r\n        for await (const item of iter) {\r\n          const asyncIteratorOutput = unsafe_writeOutput(\r\n            Tag.AsyncIterator,\r\n            iter.id,\r\n            [item]\r\n          );\r\n\r\n          const genJson = JSON.stringify(asyncIteratorOutput, null, space);\r\n          controller.enqueue(`${genJson}\\n\\n`);\r\n        }\r\n      });\r\n\r\n      await Promise.all(resolveIterators);\r\n      controller.close();\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function internal_serialize(\r\n  value: unknown,\r\n  opts: {\r\n    replacer?: Replacer | null;\r\n    initialID?: number;\r\n    space?: number | string;\r\n  }\r\n) {\r\n  const { replacer, space, initialID = 1 } = opts;\r\n  const writtenValues = new Map<number, unknown>();\r\n  const pendingPromisesMap = new Map<number, TrackingPromise<any>>();\r\n  const pendingIteratorsMap = new Map<number, TrackingAsyncIterable<any>>();\r\n  const output: unknown[] = [];\r\n  let id = initialID;\r\n\r\n  // Get the next id\r\n  const nextId = () => {\r\n    return id++;\r\n  };\r\n\r\n  // Update the references of the written values\r\n  const checkWrittenValues = () => {\r\n    for (const [id, value] of writtenValues) {\r\n      output[id] = value;\r\n    }\r\n  };\r\n\r\n  const context: SerializeContext = {\r\n    output,\r\n    writtenValues,\r\n    pendingPromisesMap,\r\n    pendingIteratorsMap,\r\n    space,\r\n    nextId,\r\n    encodeValue,\r\n    checkWrittenValues,\r\n  };\r\n\r\n  function encodeValue(input: any) {\r\n    // Custom serializer\r\n    if (replacer) {\r\n      const serialized = replacer(input, context);\r\n      if (serialized !== undefined) {\r\n        return serialized;\r\n      }\r\n    }\r\n\r\n    // Default serializer\r\n    switch (typeof input) {\r\n      case \"string\":\r\n        return `$$${input}`;\r\n      case \"boolean\":\r\n        return input;\r\n      case \"number\":\r\n        return serializeNumber(input);\r\n      case \"symbol\":\r\n        return serializeSymbol(input);\r\n      case \"undefined\":\r\n        return \"$undefined\";\r\n      case \"bigint\":\r\n        return serializeBigInt(input);\r\n      case \"object\": {\r\n        if (input === null) {\r\n          return null;\r\n        } else if (input instanceof Date) {\r\n          return serializeDate(input);\r\n        } else if (input instanceof Map) {\r\n          return serializeMap(input, context);\r\n        } else if (input instanceof Set) {\r\n          return serializeSet(input, context);\r\n        } else if (Array.isArray(input)) {\r\n          return serializeArray(input, context);\r\n        } else if (isPlainObject(input)) {\r\n          return serializePlainObject(input, context);\r\n        } else if (input instanceof Promise) {\r\n          return serializePromise(input, context);\r\n        } else if (isAsyncIterable(input)) {\r\n          return serializeAsyncIterable(input, context);\r\n        }\r\n        // Serialize typed arrrays\r\n        else if (input instanceof ArrayBuffer) {\r\n          return serializeArrayBuffer(input, context);\r\n        } else if (input instanceof Int8Array) {\r\n          return serializeTypedArray(Tag.Int8Array, input, context);\r\n        } else if (input instanceof Uint8Array) {\r\n          return serializeTypedArray(Tag.Uint8Array, input, context);\r\n        } else if (input instanceof Uint8ClampedArray) {\r\n          return serializeTypedArray(Tag.Uint8ClampedArray, input, context);\r\n        } else if (input instanceof Int16Array) {\r\n          return serializeTypedArray(Tag.Int16Array, input, context);\r\n        } else if (input instanceof Uint16Array) {\r\n          return serializeTypedArray(Tag.Uint16Array, input, context);\r\n        } else if (input instanceof Int32Array) {\r\n          return serializeTypedArray(Tag.Int32Array, input, context);\r\n        } else if (input instanceof Uint32Array) {\r\n          return serializeTypedArray(Tag.Uint32Array, input, context);\r\n        } else if (input instanceof Float32Array) {\r\n          return serializeTypedArray(Tag.Float32Array, input, context);\r\n        } else if (input instanceof Float64Array) {\r\n          return serializeTypedArray(Tag.Float64Array, input, context);\r\n        } else if (input instanceof BigInt64Array) {\r\n          return serializeTypedArray(Tag.BigInt64Array, input, context);\r\n        } else if (input instanceof BigUint64Array) {\r\n          return serializeTypedArray(Tag.BigUint64Array, input, context);\r\n        } else if (input instanceof DataView) {\r\n          return serializeTypedArray(Tag.DataView, input, context);\r\n        } else {\r\n          throw new Error(\r\n            `Unable to serialize value: ${JSON.stringify(input)}`\r\n          );\r\n        }\r\n      }\r\n      case \"function\": {\r\n        throw new Error(\"Functions cannot be serialized\");\r\n      }\r\n      default:\r\n        throw new Error(\r\n          `Unreachable. Reaching this code should be considered a bug`\r\n        );\r\n    }\r\n  }\r\n\r\n  // The base value contains all the references ids\r\n  const baseValue = encodeValue(value);\r\n  output[0] = baseValue;\r\n\r\n  checkWrittenValues();\r\n\r\n  return {\r\n    output,\r\n    get pendingPromises() {\r\n      return Array.from(pendingPromisesMap.values());\r\n    },\r\n    get pendingIterators() {\r\n      return Array.from(pendingIteratorsMap.values());\r\n    },\r\n  };\r\n}\r\n\r\nfunction serializeNumber(input: number) {\r\n  if (Number.isFinite(input)) {\r\n    if (input === 0 && 1 / input === -Infinity) {\r\n      return serializeTagValue(Tag.NegativeZero);\r\n    } else {\r\n      return input;\r\n    }\r\n  } else {\r\n    if (input === Infinity) {\r\n      return serializeTagValue(Tag.Infinity_);\r\n    } else if (input === -Infinity) {\r\n      return serializeTagValue(Tag.NegativeInfinity);\r\n    } else {\r\n      return serializeTagValue(Tag.NaN_);\r\n    }\r\n  }\r\n}\r\n\r\nfunction serializeSymbol(input: symbol) {\r\n  return serializeTagValue(Tag.Symbol, input.description);\r\n}\r\n\r\nfunction serializeBigInt(input: bigint) {\r\n  return serializeTagValue(Tag.BigInt, String(input));\r\n}\r\n\r\nfunction serializeDate(input: Date) {\r\n  return serializeTagValue(Tag.Date, input.toJSON());\r\n}\r\n\r\nfunction serializeArray(input: Array<any>, context: SerializeContext) {\r\n  const items: unknown[] = [];\r\n\r\n  for (const val of input) {\r\n    items.push(context.encodeValue(val));\r\n  }\r\n\r\n  return items;\r\n}\r\n\r\nfunction serializeSet(input: Set<any>, context: SerializeContext) {\r\n  const { writtenValues: referencesMap } = context;\r\n  const items: unknown[] = [];\r\n\r\n  for (const val of input) {\r\n    items.push(context.encodeValue(val));\r\n  }\r\n\r\n  const id = context.nextId();\r\n  referencesMap.set(id, items);\r\n  return serializeTagValue(Tag.Set, id);\r\n}\r\n\r\nfunction serializeMap(input: Map<any, any>, context: SerializeContext) {\r\n  const { writtenValues: referencesMap } = context;\r\n  const items: [unknown, unknown][] = [];\r\n\r\n  for (const [k, v] of input) {\r\n    const encodedKey = context.encodeValue(k);\r\n    const encodedValue = context.encodeValue(v);\r\n    items.push([encodedKey, encodedValue]);\r\n  }\r\n\r\n  const id = context.nextId();\r\n  referencesMap.set(id, items);\r\n  return serializeTagValue(Tag.Map, id);\r\n}\r\n\r\nfunction serializePlainObject(\r\n  input: Record<string, unknown>,\r\n  context: SerializeContext\r\n) {\r\n  const obj: Record<string, unknown> = {};\r\n\r\n  for (const [key, value] of Object.entries(input)) {\r\n    obj[key] = context.encodeValue(value);\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nfunction serializePromise(input: Promise<any>, context: SerializeContext) {\r\n  const id = context.nextId();\r\n\r\n  // We create a new promise that resolve to the serialized value\r\n  const resolvingPromise = input.then((value) => {\r\n    const ret = context.encodeValue(value);\r\n    context.writtenValues.set(id, ret);\r\n    context.checkWrittenValues(); // Update the values with the new one\r\n    return value;\r\n  });\r\n\r\n  const trackingPromise = trackPromise(id, resolvingPromise);\r\n  context.pendingPromisesMap.set(id, trackingPromise);\r\n  return serializeTagValue(Tag.Promise, id);\r\n}\r\n\r\nfunction serializeArrayBuffer(input: ArrayBuffer, context: SerializeContext) {\r\n  return serializeTypedArray(Tag.ArrayBuffer, new Uint8Array(input), context);\r\n}\r\n\r\nfunction serializeTypedArray(\r\n  tag: Tag,\r\n  input: ArrayBufferView,\r\n  context: SerializeContext\r\n) {\r\n  const id = context.nextId();\r\n  const buffer = bufferToBase64(input.buffer);\r\n  context.writtenValues.set(id, buffer);\r\n  return serializeTagValue(tag, id);\r\n}\r\n\r\nfunction serializeAsyncIterable(\r\n  input: AsyncIterable<unknown>,\r\n  context: SerializeContext\r\n) {\r\n  const id = context.nextId();\r\n\r\n  // We send all the async iterable emited and any nested async iterable values.\r\n  // Flattening the nested iterable would make no sense because we are not returning the exact\r\n  // value was originally stringified. So we could:\r\n  // 1. Throw an error and don't stringify nested async iterables\r\n  // 2. Attempt to stringify nested async iterables which could lead to infinite loops.\r\n  async function* resolveAsyncIterable(\r\n    iter: AsyncIterable<unknown>\r\n  ): AsyncGenerator<unknown> {\r\n    for await (const item of iter) {\r\n      if (isAsyncIterable(item)) {\r\n        // console.warn(\"Avoid returning nested async iterables, prefer using `yield*` instead\")\r\n        yield* resolveAsyncIterable(item);\r\n      } else {\r\n        yield item;\r\n      }\r\n    }\r\n  }\r\n\r\n  const generator = (async function* () {\r\n    for await (const item of resolveAsyncIterable(input)) {\r\n      const ret = context.encodeValue(item);\r\n\r\n      // Push the new generated value\r\n      const items = [...((context.output[id] as any[]) || []), ret];\r\n      context.writtenValues.set(id, items);\r\n      context.checkWrittenValues();\r\n      yield ret;\r\n    }\r\n\r\n    // Notify is done\r\n    const items = [...((context.output[id] as any[]) || []), \"done\"];\r\n    context.writtenValues.set(id, items);\r\n    context.checkWrittenValues();\r\n    yield \"done\";\r\n  })();\r\n\r\n  const tracked = trackAsyncIterable(id, generator);\r\n  context.pendingIteratorsMap.set(id, tracked);\r\n  return serializeTagValue(Tag.AsyncIterator, id);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function serializeTagValue(tag: Tag, value?: number | string) {\r\n  return value ? `$${tag}${value}` : `$${tag}`;\r\n}\r\n\r\nfunction unsafe_writeOutput(tag: Tag, id: number, value: unknown) {\r\n  const output: unknown[] = [serializeTagValue(tag, id)];\r\n  output[id] = value;\r\n  return output;\r\n}\r\n\r\nfunction isAsyncIterable(value: any): value is AsyncIterable<unknown> {\r\n  return value != null && typeof value[Symbol.asyncIterator] === \"function\";\r\n}\r\n","export type Sender<T> = {\r\n  id: number;\r\n  send: (value: T | Promise<T>) => void;\r\n  close: () => void;\r\n};\r\n\r\nexport type Receiver<T> = {\r\n  id: number;\r\n  recv: () => Promise<T | undefined>;\r\n  next: () => Promise<IteratorResult<T | undefined>>;\r\n  isClosed: () => boolean;\r\n  [Symbol.asyncIterator]: () => AsyncIterator<T>;\r\n};\r\n\r\ntype ChannelOptions = {\r\n  id: number;\r\n};\r\n\r\ntype ResolvePromise<T> = (value: T | Promise<T> | undefined) => void;\r\n\r\n/**\r\n * Create a multi-producer and single consumer channel.\r\n * @param options Options used to create the channel.\r\n * @returns A tuple with the sender and receiver.\r\n */\r\nexport function createChannel<T>(options: ChannelOptions) {\r\n  const { id } = options;\r\n  const queue: Promise<T>[] = [];\r\n  const resolveQueue: ResolvePromise<T>[] = [];\r\n  let closed = false;\r\n\r\n  function send(value: T | Promise<T>) {\r\n    if (closed) {\r\n      throw new Error(\"Channel was closed\");\r\n    }\r\n\r\n    const promise = value instanceof Promise ? value : Promise.resolve(value);\r\n    const resolve = resolveQueue.shift();\r\n\r\n    if (resolve) {\r\n      resolve(promise);\r\n    } else {\r\n      queue.push(promise);\r\n    }\r\n  }\r\n\r\n  async function recv() {\r\n    if (closed && queue.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    const promise = queue.shift();\r\n\r\n    if (promise) {\r\n      return promise;\r\n    }\r\n\r\n    return new Promise<T | undefined>((resolve) => {\r\n      resolveQueue.push(resolve);\r\n    });\r\n  }\r\n\r\n  async function* asyncIterator() {\r\n    while (true) {\r\n      const item = await recv();\r\n\r\n      if (item === undefined) {\r\n        break;\r\n      }\r\n\r\n      yield item;\r\n    }\r\n  }\r\n\r\n  async function next(): Promise<IteratorResult<T | undefined>> {\r\n    const value = await recv();\r\n    return { done: closed, value };\r\n  }\r\n\r\n  const sender: Sender<T> = {\r\n    id,\r\n    send,\r\n    close: () => {\r\n      closed = true;\r\n\r\n      // resolve each pending with undefined\r\n      const pendingResolve = resolveQueue.splice(0, resolveQueue.length);\r\n      for (const resolve of pendingResolve) {\r\n        resolve(undefined);\r\n      }\r\n    },\r\n  };\r\n\r\n  const receiver: Receiver<T> = {\r\n    id,\r\n    recv,\r\n    next,\r\n    isClosed: () => closed,\r\n    [Symbol.asyncIterator]: asyncIterator,\r\n  };\r\n\r\n  return [sender, receiver] as const;\r\n}\r\n","export type DeferredPromise<T> = {\r\n  promise: Promise<T>;\r\n  resolve: (value: T | PromiseLike<T>) => void;\r\n  reject: (reason: unknown) => void;\r\n};\r\n\r\nexport function deferredPromise<T>(): DeferredPromise<T> {\r\n  let resolve = (_value: T | PromiseLike<T>) => {};\r\n  let reject = (_reason: unknown) => {};\r\n\r\n  const promise = new Promise<T>((resolve_, reject_) => {\r\n    resolve = resolve_;\r\n    reject = reject_;\r\n  });\r\n\r\n  return {\r\n    promise,\r\n    resolve,\r\n    reject,\r\n  };\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { createChannel, type Sender } from \"../channel\";\r\nimport { deferredPromise, type DeferredPromise } from \"../deferredPromise\";\r\nimport { Tag, isTypedArrayTag } from \"../tag\";\r\nimport {\r\n  isTrackingAsyncIterable,\r\n  trackAsyncIterable,\r\n} from \"../trackingAsyncIterable\";\r\nimport { isTrackingPromise, trackPromise } from \"../trackingPromise\";\r\nimport { base64ToBuffer, isPlainObject } from \"../utils\";\r\n\r\ntype Context = {\r\n  references: readonly unknown[];\r\n};\r\n\r\n/**\r\n * A function that convert a value.\r\n */\r\nexport type Reviver = (value: any) => any | undefined;\r\n\r\n/**\r\n * Parse a `json` string to a value.\r\n * @param value The `json` value to parse.\r\n * @param reviver A function to convert a value.\r\n * @returns The parsed value.\r\n */\r\nexport function parse(value: string, reviver?: Reviver): unknown {\r\n  const result = internal_parseValue(value, { reviver });\r\n  return result.data;\r\n}\r\n\r\n/**\r\n * Takes a stream and parse each value until it resolves.\r\n * @param stream The stream to parse.\r\n * @param reviver A function to convert a value.\r\n * @returns A promise that resolve to the parsed value.\r\n */\r\nexport async function parseFromStream(\r\n  stream: ReadableStream<string>,\r\n  reviver?: Reviver\r\n) {\r\n  const reader = internal_parseFromStream(stream, reviver).getReader();\r\n  let resolved = false;\r\n  const deferred = deferredPromise();\r\n\r\n  void Promise.resolve().then(async () => {\r\n    const promises: Promise<any>[] = [];\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      const { done, value } = await reader.read();\r\n      if (done || value === undefined) {\r\n        break;\r\n      }\r\n\r\n      if (!resolved) {\r\n        resolved = true;\r\n        deferred.resolve(value);\r\n      }\r\n\r\n      if (value instanceof Promise) {\r\n        promises.push(value);\r\n      }\r\n    }\r\n\r\n    if (!resolved) {\r\n      deferred.reject(new Error(\"Unable to find resolved value\"));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n  });\r\n\r\n  return deferred.promise;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function internal_parseFromStream(\r\n  stream: ReadableStream<string>,\r\n  reviver?: Reviver\r\n) {\r\n  const promisesMap = new Map<number, DeferredPromise<unknown>>();\r\n  const channelsMap = new Map<number, Sender<unknown>>();\r\n  const reader = stream.getReader();\r\n\r\n  return new ReadableStream<unknown>({\r\n    async start(controller) {\r\n      async function processChunk(jsonChunk: string) {\r\n        const { data, pendingPromises, pendingChannels } = internal_parseValue(\r\n          jsonChunk,\r\n          {\r\n            deferPromises: true,\r\n            reviver,\r\n          }\r\n        );\r\n\r\n        // Send the value\r\n        controller.enqueue(data);\r\n\r\n        // Handle promises\r\n        {\r\n          for (const [id, deferred] of pendingPromises.entries()) {\r\n            promisesMap.set(id, deferred);\r\n          }\r\n\r\n          // Resolve a pending promise\r\n          if (isTrackingPromise(data)) {\r\n            const deferred = promisesMap.get(data.id);\r\n\r\n            if (!deferred) {\r\n              throw new Error(`Promise with id: '${data.id}' was not found`);\r\n            }\r\n\r\n            try {\r\n              const returnValue = await data;\r\n              deferred.resolve(returnValue);\r\n            } catch (err) {\r\n              deferred.reject(err);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Handle async iterators\r\n        {\r\n          if (pendingChannels.size > 0) {\r\n            for (const [id, channelSender] of pendingChannels.entries()) {\r\n              channelsMap.set(id, channelSender);\r\n            }\r\n          }\r\n\r\n          if (isTrackingAsyncIterable(data)) {\r\n            const sender = channelsMap.get(data.id);\r\n\r\n            if (!sender) {\r\n              throw new Error(\r\n                `AsyncIterator sender with id '${data.id}' was not found`\r\n              );\r\n            }\r\n\r\n            const isDone = data.context === \"done\";\r\n            for await (const item of data) {\r\n              sender.send(item);\r\n            }\r\n\r\n            if (isDone) {\r\n              sender.close();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      while (true) {\r\n        const { done, value: raw } = await reader.read();\r\n        if (done || raw === undefined) {\r\n          break;\r\n        }\r\n\r\n        const chunks = raw.split(\"\\n\\n\").filter(Boolean);\r\n\r\n        // We process all chunks at once if possible\r\n        if (chunks.length > 1) {\r\n          const promises = chunks.map(processChunk);\r\n          await Promise.all(promises);\r\n        } else {\r\n          await processChunk(chunks[0]);\r\n        }\r\n      }\r\n\r\n      controller.close();\r\n    },\r\n  });\r\n}\r\n\r\ntype Options = {\r\n  deferPromises?: boolean;\r\n  reviver?: Reviver;\r\n};\r\n\r\nfunction internal_parseValue(value: string, opts?: Options) {\r\n  const { deferPromises = false, reviver } = opts || {};\r\n  const pendingPromises = new Map<number, DeferredPromise<unknown>>();\r\n  const pendingChannels = new Map<number, Sender<unknown>>();\r\n\r\n  const { references, base } = (function () {\r\n    try {\r\n      const references = JSON.parse(value) as readonly unknown[];\r\n      return { references, base: references[0] };\r\n    } catch {\r\n      throw new Error(`Failed to parse base value: ${value}`);\r\n    }\r\n  })();\r\n\r\n  const deserizalizeValue = (input: any): unknown => {\r\n    if (reviver) {\r\n      const ret = reviver(input);\r\n      if (ret !== undefined) {\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    switch (typeof input) {\r\n      case \"number\":\r\n        return input;\r\n      case \"boolean\":\r\n        return input;\r\n      case \"string\": {\r\n        if (input[0] === \"$\") {\r\n          const maybeTag = input.slice(1);\r\n\r\n          switch (true) {\r\n            case maybeTag[0] === Tag.String: {\r\n              return input.slice(2);\r\n            }\r\n            case maybeTag[0] === Tag.Symbol: {\r\n              return Symbol.for(input.slice(2));\r\n            }\r\n            case maybeTag[0] === Tag.Date: {\r\n              return new Date(input.slice(2));\r\n            }\r\n            case maybeTag[0] === Tag.BigInt: {\r\n              return BigInt(input.slice(2));\r\n            }\r\n            case maybeTag === Tag.Undefined: {\r\n              return undefined;\r\n            }\r\n            case maybeTag === Tag.Infinity_: {\r\n              return Infinity;\r\n            }\r\n            case maybeTag === Tag.NegativeInfinity: {\r\n              return -Infinity;\r\n            }\r\n            case maybeTag === Tag.NegativeZero: {\r\n              return -0;\r\n            }\r\n            case maybeTag === Tag.NaN_: {\r\n              return NaN;\r\n            }\r\n            case maybeTag[0] === Tag.Set: {\r\n              const id = parseTagId(input.slice(2));\r\n              const set = new Set<any>();\r\n\r\n              try {\r\n                const values = references[id];\r\n                if (values) {\r\n                  if (Array.isArray(values)) {\r\n                    for (const item of values) {\r\n                      set.add(deserizalizeValue(item));\r\n                    }\r\n                  }\r\n                }\r\n              } catch (err) {\r\n                // failed to parse\r\n                console.error(err);\r\n              }\r\n\r\n              return set;\r\n            }\r\n            case maybeTag[0] === Tag.Map: {\r\n              const id = parseTagId(input.slice(2));\r\n              const map = new Map<any, any>();\r\n\r\n              try {\r\n                const values = references[id];\r\n                if (values) {\r\n                  if (Array.isArray(values)) {\r\n                    for (const [key, value] of values) {\r\n                      const decodedKey = deserizalizeValue(key);\r\n                      const decodedValue = deserizalizeValue(value);\r\n                      map.set(decodedKey, decodedValue);\r\n                    }\r\n                  }\r\n                }\r\n              } catch (err) {\r\n                // failed to parse\r\n                console.error(err);\r\n              }\r\n\r\n              return map;\r\n            }\r\n            case maybeTag[0] === Tag.Promise: {\r\n              const id = parseTagId(input.slice(2));\r\n              const rawValue = references[id];\r\n\r\n              if (rawValue === undefined) {\r\n                if (deferPromises) {\r\n                  const deferred = deferredPromise();\r\n                  pendingPromises.set(id, deferred);\r\n                  return deferred.promise;\r\n                }\r\n\r\n                throw new Error(\"Failed to find promise resolved value\");\r\n              }\r\n\r\n              try {\r\n                const resolvedValue = deserizalizeValue(rawValue);\r\n                return trackPromise(id, Promise.resolve(resolvedValue));\r\n              } catch {\r\n                throw new Error(\"Unable to resolve promise value\");\r\n              }\r\n            }\r\n            case maybeTag[0] === Tag.AsyncIterator: {\r\n              const id = parseTagId(input.slice(2));\r\n              const asyncIteratorValues = references[id];\r\n\r\n              if (!asyncIteratorValues) {\r\n                const [sender, receiver] = createChannel({ id });\r\n                pendingChannels.set(id, sender);\r\n                return receiver;\r\n              }\r\n\r\n              if (Array.isArray(asyncIteratorValues)) {\r\n                const length = asyncIteratorValues.length - 1;\r\n                const isDone = asyncIteratorValues[length] === \"done\";\r\n\r\n                const values = isDone\r\n                  ? asyncIteratorValues.slice(0, -1)\r\n                  : asyncIteratorValues;\r\n\r\n                const generator = (async function* () {\r\n                  for (const item of values) {\r\n                    const resolvedValue = deserizalizeValue(item);\r\n                    yield resolvedValue;\r\n                  }\r\n                })();\r\n\r\n                const trackedAsyncIterator = trackAsyncIterable(\r\n                  id,\r\n                  generator,\r\n                  isDone ? \"done\" : undefined\r\n                );\r\n\r\n                return trackedAsyncIterator;\r\n              } else {\r\n                throw new Error(\r\n                  \"Failed to parse async iterator, expected array of values\"\r\n                );\r\n              }\r\n            }\r\n            case isTypedArrayTag(maybeTag[0]): {\r\n              return deserializeBuffer(maybeTag[0], input, {\r\n                references,\r\n              });\r\n            }\r\n            default:\r\n              throw new Error(`Unknown reference value: ${input}`);\r\n          }\r\n        } else {\r\n          throw new Error(`Invalid reference value: ${input}`);\r\n        }\r\n      }\r\n      case \"object\": {\r\n        if (input === null) {\r\n          return null;\r\n        } else if (Array.isArray(input)) {\r\n          const arr: any[] = [];\r\n          for (const item of input) {\r\n            arr.push(deserizalizeValue(item));\r\n          }\r\n          return arr;\r\n        } else if (isPlainObject(input)) {\r\n          const obj: Record<string, unknown> = {};\r\n\r\n          for (const [key, value] of Object.entries(input)) {\r\n            obj[key] = deserizalizeValue(value);\r\n          }\r\n\r\n          return obj;\r\n        } else {\r\n          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);\r\n        }\r\n      }\r\n      default:\r\n        throw new Error(`Invalid value: ${input}`);\r\n    }\r\n  };\r\n\r\n  const data = deserizalizeValue(base);\r\n  return { data, pendingPromises, pendingChannels };\r\n}\r\n\r\nfunction deserializeBuffer(tag: Tag, input: string, context: Context) {\r\n  const getBufferData = () => {\r\n    const id = parseTagId(input.slice(2));\r\n    const data = context.references[id];\r\n    if (!data) {\r\n      throw new Error(`Unable to get '${input}' buffer data`);\r\n    }\r\n    return String(data);\r\n  };\r\n\r\n  switch (tag) {\r\n    case Tag.ArrayBuffer: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return bytes.buffer;\r\n    }\r\n    case Tag.Int8Array:\r\n      return base64ToBuffer(getBufferData(), Int8Array);\r\n    case Tag.Uint8Array:\r\n      return base64ToBuffer(getBufferData(), Uint8Array);\r\n    case Tag.Uint8ClampedArray:\r\n      return base64ToBuffer(getBufferData(), Uint8ClampedArray);\r\n    case Tag.Int16Array:\r\n      return base64ToBuffer(getBufferData(), Int16Array);\r\n    case Tag.Uint16Array:\r\n      return base64ToBuffer(getBufferData(), Uint16Array);\r\n    case Tag.Int32Array:\r\n      return base64ToBuffer(getBufferData(), Int32Array);\r\n    case Tag.Uint32Array:\r\n      return base64ToBuffer(getBufferData(), Uint32Array);\r\n    case Tag.Float32Array:\r\n      return base64ToBuffer(getBufferData(), Float32Array);\r\n    case Tag.Float64Array:\r\n      return base64ToBuffer(getBufferData(), Float64Array);\r\n    case Tag.BigInt64Array: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new BigInt64Array(bytes.buffer);\r\n    }\r\n    case Tag.BigUint64Array: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new BigUint64Array(bytes.buffer);\r\n    }\r\n    case Tag.DataView: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new DataView(bytes.buffer);\r\n    }\r\n    default:\r\n      throw new Error(`Unknown typed array buffer: ${input}`);\r\n  }\r\n}\r\n\r\nfunction parseTagId(input: string) {\r\n  const id = parseInt(input);\r\n\r\n  if (!Number.isFinite(id) || Number.isNaN(id)) {\r\n    throw new Error(`Invalid tag id: '${input}'`);\r\n  }\r\n\r\n  return id;\r\n}\r\n"],"mappings":"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","names":["id","value","items","references","value"]}
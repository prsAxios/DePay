import {
  createChannel
} from "./chunk-2BFJZQPL.js";
import {
  deferredPromise
} from "./chunk-RKI2CCYJ.js";
import {
  isTypedArrayTag
} from "./chunk-FGICQ6M6.js";
import {
  isTrackingAsyncIterable,
  trackAsyncIterable
} from "./chunk-EYHFEQUS.js";
import {
  isTrackingPromise,
  trackPromise
} from "./chunk-4VKTSAMC.js";
import {
  base64ToBuffer,
  isPlainObject
} from "./chunk-ZZBOA43I.js";

// src/json/parse.ts
function parse(value, reviver) {
  const result = internal_parseValue(value, { reviver });
  return result.data;
}
async function parseFromStream(stream, reviver) {
  const reader = internal_parseFromStream(stream, reviver).getReader();
  let resolved = false;
  const deferred = deferredPromise();
  void Promise.resolve().then(async () => {
    const promises = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done || value === void 0) {
        break;
      }
      if (!resolved) {
        resolved = true;
        deferred.resolve(value);
      }
      if (value instanceof Promise) {
        promises.push(value);
      }
    }
    if (!resolved) {
      deferred.reject(new Error("Unable to find resolved value"));
    }
    await Promise.all(promises);
  });
  return deferred.promise;
}
function internal_parseFromStream(stream, reviver) {
  const promisesMap = /* @__PURE__ */ new Map();
  const channelsMap = /* @__PURE__ */ new Map();
  const reader = stream.getReader();
  return new ReadableStream({
    async start(controller) {
      async function processChunk(jsonChunk) {
        const { data, pendingPromises, pendingChannels } = internal_parseValue(
          jsonChunk,
          {
            deferPromises: true,
            reviver
          }
        );
        controller.enqueue(data);
        {
          for (const [id, deferred] of pendingPromises.entries()) {
            promisesMap.set(id, deferred);
          }
          if (isTrackingPromise(data)) {
            const deferred = promisesMap.get(data.id);
            if (!deferred) {
              throw new Error(`Promise with id: '${data.id}' was not found`);
            }
            try {
              const returnValue = await data;
              deferred.resolve(returnValue);
            } catch (err) {
              deferred.reject(err);
            }
          }
        }
        {
          if (pendingChannels.size > 0) {
            for (const [id, channelSender] of pendingChannels.entries()) {
              channelsMap.set(id, channelSender);
            }
          }
          if (isTrackingAsyncIterable(data)) {
            const sender = channelsMap.get(data.id);
            if (!sender) {
              throw new Error(
                `AsyncIterator sender with id '${data.id}' was not found`
              );
            }
            const isDone = data.context === "done";
            for await (const item of data) {
              sender.send(item);
            }
            if (isDone) {
              sender.close();
            }
          }
        }
      }
      while (true) {
        const { done, value: raw } = await reader.read();
        if (done || raw === void 0) {
          break;
        }
        const chunks = raw.split("\n\n").filter(Boolean);
        if (chunks.length > 1) {
          const promises = chunks.map(processChunk);
          await Promise.all(promises);
        } else {
          await processChunk(chunks[0]);
        }
      }
      controller.close();
    }
  });
}
function internal_parseValue(value, opts) {
  const { deferPromises = false, reviver } = opts || {};
  const pendingPromises = /* @__PURE__ */ new Map();
  const pendingChannels = /* @__PURE__ */ new Map();
  const { references, base } = function() {
    try {
      const references2 = JSON.parse(value);
      return { references: references2, base: references2[0] };
    } catch {
      throw new Error(`Failed to parse base value: ${value}`);
    }
  }();
  const deserizalizeValue = (input) => {
    if (reviver) {
      const ret = reviver(input);
      if (ret !== void 0) {
        return ret;
      }
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input;
      case "string": {
        if (input[0] === "$") {
          const maybeTag = input.slice(1);
          switch (true) {
            case maybeTag[0] === "$" /* String */: {
              return input.slice(2);
            }
            case maybeTag[0] === "S" /* Symbol */: {
              return Symbol.for(input.slice(2));
            }
            case maybeTag[0] === "D" /* Date */: {
              return new Date(input.slice(2));
            }
            case maybeTag[0] === "n" /* BigInt */: {
              return BigInt(input.slice(2));
            }
            case maybeTag === "undefined" /* Undefined */: {
              return void 0;
            }
            case maybeTag === "Infinity" /* Infinity_ */: {
              return Infinity;
            }
            case maybeTag === "-Infinity" /* NegativeInfinity */: {
              return -Infinity;
            }
            case maybeTag === "-0" /* NegativeZero */: {
              return -0;
            }
            case maybeTag === "NaN" /* NaN_ */: {
              return NaN;
            }
            case maybeTag[0] === "W" /* Set */: {
              const id = parseTagId(input.slice(2));
              const set = /* @__PURE__ */ new Set();
              try {
                const values = references[id];
                if (values) {
                  if (Array.isArray(values)) {
                    for (const item of values) {
                      set.add(deserizalizeValue(item));
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return set;
            }
            case maybeTag[0] === "Q" /* Map */: {
              const id = parseTagId(input.slice(2));
              const map = /* @__PURE__ */ new Map();
              try {
                const values = references[id];
                if (values) {
                  if (Array.isArray(values)) {
                    for (const [key, value2] of values) {
                      const decodedKey = deserizalizeValue(key);
                      const decodedValue = deserizalizeValue(value2);
                      map.set(decodedKey, decodedValue);
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return map;
            }
            case maybeTag[0] === "@" /* Promise */: {
              const id = parseTagId(input.slice(2));
              const rawValue = references[id];
              if (rawValue === void 0) {
                if (deferPromises) {
                  const deferred = deferredPromise();
                  pendingPromises.set(id, deferred);
                  return deferred.promise;
                }
                throw new Error("Failed to find promise resolved value");
              }
              try {
                const resolvedValue = deserizalizeValue(rawValue);
                return trackPromise(id, Promise.resolve(resolvedValue));
              } catch {
                throw new Error("Unable to resolve promise value");
              }
            }
            case maybeTag[0] === "#" /* AsyncIterator */: {
              const id = parseTagId(input.slice(2));
              const asyncIteratorValues = references[id];
              if (!asyncIteratorValues) {
                const [sender, receiver] = createChannel({ id });
                pendingChannels.set(id, sender);
                return receiver;
              }
              if (Array.isArray(asyncIteratorValues)) {
                const length = asyncIteratorValues.length - 1;
                const isDone = asyncIteratorValues[length] === "done";
                const values = isDone ? asyncIteratorValues.slice(0, -1) : asyncIteratorValues;
                const generator = async function* () {
                  for (const item of values) {
                    const resolvedValue = deserizalizeValue(item);
                    yield resolvedValue;
                  }
                }();
                const trackedAsyncIterator = trackAsyncIterable(
                  id,
                  generator,
                  isDone ? "done" : void 0
                );
                return trackedAsyncIterator;
              } else {
                throw new Error(
                  "Failed to parse async iterator, expected array of values"
                );
              }
            }
            case isTypedArrayTag(maybeTag[0]): {
              return deserializeBuffer(maybeTag[0], input, {
                references
              });
            }
            default:
              throw new Error(`Unknown reference value: ${input}`);
          }
        } else {
          throw new Error(`Invalid reference value: ${input}`);
        }
      }
      case "object": {
        if (input === null) {
          return null;
        } else if (Array.isArray(input)) {
          const arr = [];
          for (const item of input) {
            arr.push(deserizalizeValue(item));
          }
          return arr;
        } else if (isPlainObject(input)) {
          const obj = {};
          for (const [key, value2] of Object.entries(input)) {
            obj[key] = deserizalizeValue(value2);
          }
          return obj;
        } else {
          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);
        }
      }
      default:
        throw new Error(`Invalid value: ${input}`);
    }
  };
  const data = deserizalizeValue(base);
  return { data, pendingPromises, pendingChannels };
}
function deserializeBuffer(tag, input, context) {
  const getBufferData = () => {
    const id = parseTagId(input.slice(2));
    const data = context.references[id];
    if (!data) {
      throw new Error(`Unable to get '${input}' buffer data`);
    }
    return String(data);
  };
  switch (tag) {
    case "A" /* ArrayBuffer */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return bytes.buffer;
    }
    case "C" /* Int8Array */:
      return base64ToBuffer(getBufferData(), Int8Array);
    case "c" /* Uint8Array */:
      return base64ToBuffer(getBufferData(), Uint8Array);
    case "U" /* Uint8ClampedArray */:
      return base64ToBuffer(getBufferData(), Uint8ClampedArray);
    case "P" /* Int16Array */:
      return base64ToBuffer(getBufferData(), Int16Array);
    case "p" /* Uint16Array */:
      return base64ToBuffer(getBufferData(), Uint16Array);
    case "L" /* Int32Array */:
      return base64ToBuffer(getBufferData(), Int32Array);
    case "l" /* Uint32Array */:
      return base64ToBuffer(getBufferData(), Uint32Array);
    case "F" /* Float32Array */:
      return base64ToBuffer(getBufferData(), Float32Array);
    case "d" /* Float64Array */:
      return base64ToBuffer(getBufferData(), Float64Array);
    case "N" /* BigInt64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigInt64Array(bytes.buffer);
    }
    case "m" /* BigUint64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigUint64Array(bytes.buffer);
    }
    case "V" /* DataView */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new DataView(bytes.buffer);
    }
    default:
      throw new Error(`Unknown typed array buffer: ${input}`);
  }
}
function parseTagId(input) {
  const id = parseInt(input);
  if (!Number.isFinite(id) || Number.isNaN(id)) {
    throw new Error(`Invalid tag id: '${input}'`);
  }
  return id;
}

export {
  parse,
  parseFromStream,
  internal_parseFromStream
};
//# sourceMappingURL=chunk-226NSOGJ.js.map
import {
  internal_serialize,
  serializeTagValue
} from "../chunk-LRUJGSZG.js";
import {
  isTypedArrayTag
} from "../chunk-FGICQ6M6.js";
import "../chunk-EYHFEQUS.js";
import "../chunk-4VKTSAMC.js";
import {
  base64ToBuffer,
  isPlainObject
} from "../chunk-ZZBOA43I.js";

// src/form-data/index.ts
function encode(value, replacer) {
  const formData = new FormData();
  const { output, pendingPromises, pendingIterators } = internal_encodeFormData(
    value,
    {
      formData,
      replacer
    }
  );
  if (pendingPromises.length > 0) {
    throw new Error("Serialiation result have pending promises");
  }
  if (pendingIterators.length > 0) {
    throw new Error("Serialiation result have pending async iterators");
  }
  for (let i = 0; i < output.length; i++) {
    formData.set(String(i), JSON.stringify(output[i]));
  }
  return formData;
}
async function encodeAsync(value, replacer) {
  const formData = new FormData();
  const result = internal_encodeFormData(value, {
    formData,
    replacer
  });
  await Promise.all(result.pendingPromises);
  const iteratorPromises = result.pendingIterators.map(async (iter) => {
    for await (const _ of iter) {
    }
  });
  await Promise.all(iteratorPromises);
  for (let i = 0; i < result.output.length; i++) {
    formData.set(String(i), JSON.stringify(result.output[i]));
  }
  return formData;
}
function internal_encodeFormData(value, opts) {
  const { formData, replacer: _replacer } = opts;
  return internal_serialize(value, {
    replacer: (input, ctx) => {
      if (_replacer) {
        const ret = _replacer(input, ctx);
        if (ret !== void 0) {
          return ret;
        }
      }
      if (input instanceof FormData) {
        const id = ctx.nextId();
        for (const [key, entry] of input) {
          const fieldName = `${id}_${key}`;
          formData.set(fieldName, entry);
        }
        return serializeTagValue("K" /* FormData */, id);
      }
      if (input instanceof File) {
        const id = ctx.nextId();
        formData.set(`${id}_file`, input);
        return serializeTagValue("k" /* File */, id);
      }
      return void 0;
    }
  });
}
function decode(value, reviver, opts) {
  const { types } = opts || {};
  const { FormData: FormDataConstructor = globalThis.FormData } = types || {};
  const baseValue = function() {
    const entry = value.get("0");
    if (!entry) {
      throw new Error("Empty value to decode");
    }
    try {
      return JSON.parse(String(entry));
    } catch {
      throw new Error(`Failed to parse base value: ${entry}`);
    }
  }();
  const deserizalizeValue = (input) => {
    if (reviver) {
      const ret = reviver(input);
      if (ret !== void 0) {
        return ret;
      }
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input;
      case "string": {
        if (input[0] === "$") {
          const maybeTag = input.slice(1);
          switch (true) {
            case maybeTag[0] === "$" /* String */: {
              return input.slice(2);
            }
            case maybeTag[0] === "S" /* Symbol */: {
              return Symbol.for(input.slice(2));
            }
            case maybeTag[0] === "D" /* Date */: {
              return new Date(input.slice(2));
            }
            case maybeTag[0] === "n" /* BigInt */: {
              return BigInt(input.slice(2));
            }
            case maybeTag === "undefined" /* Undefined */: {
              return void 0;
            }
            case maybeTag === "Infinity" /* Infinity_ */: {
              return Infinity;
            }
            case maybeTag === "-Infinity" /* NegativeInfinity */: {
              return -Infinity;
            }
            case maybeTag === "-0" /* NegativeZero */: {
              return -0;
            }
            case maybeTag === "NaN" /* NaN_ */: {
              return NaN;
            }
            case maybeTag[0] === "W" /* Set */: {
              const id = input.slice(2);
              const set = /* @__PURE__ */ new Set();
              try {
                const values = value.get(id);
                if (values) {
                  const data = JSON.parse(String(values));
                  if (Array.isArray(data)) {
                    for (const item of data) {
                      set.add(deserizalizeValue(item));
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return set;
            }
            case maybeTag[0] === "Q" /* Map */: {
              const id = input.slice(2);
              const map = /* @__PURE__ */ new Map();
              try {
                const values = value.get(id);
                if (values) {
                  const data = JSON.parse(String(values));
                  if (Array.isArray(data)) {
                    for (const [key, value2] of data) {
                      const decodedKey = deserizalizeValue(key);
                      const decodedValue = deserizalizeValue(value2);
                      map.set(decodedKey, decodedValue);
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return map;
            }
            case maybeTag[0] === "@" /* Promise */: {
              const id = input.slice(2);
              const rawValue = value.get(id);
              if (!rawValue) {
                throw new Error("Failed to find promise resolved value");
              }
              try {
                const resolvedValue = deserizalizeValue(
                  JSON.parse(String(rawValue))
                );
                return Promise.resolve(resolvedValue);
              } catch {
                throw new Error("Unable to resolve promise value");
              }
            }
            case maybeTag[0] === "#" /* AsyncIterator */: {
              const id = input.slice(2);
              const json = value.get(id);
              if (!json) {
                throw new Error(`Unable to get async iterator '${id}'`);
              }
              const asyncIteratorValues = JSON.parse(String(json));
              if (Array.isArray(asyncIteratorValues)) {
                const length = asyncIteratorValues.length - 1;
                const isDone = asyncIteratorValues[length] === "done";
                const values = isDone ? asyncIteratorValues.slice(0, -1) : asyncIteratorValues;
                const generator = async function* () {
                  for (const item of values) {
                    const resolvedValue = deserizalizeValue(item);
                    yield resolvedValue;
                  }
                }();
                return generator;
              } else {
                throw new Error(
                  "Failed to parse async iterator, expected array of values"
                );
              }
            }
            case maybeTag[0] === "K" /* FormData */: {
              const formData = new FormDataConstructor();
              const id = input.slice(2);
              value.forEach((entry, key) => {
                const entryKey = `${id}_`;
                if (key.startsWith(entryKey)) {
                  const fieldName = key.slice(entryKey.length);
                  formData.set(fieldName, entry);
                }
              });
              return formData;
            }
            case isTypedArrayTag(maybeTag[0]): {
              return deserializeBuffer(maybeTag[0], input, {
                references: value
              });
            }
            case maybeTag[0] === "k" /* File */: {
              const id = input.slice(2);
              const file = value.get(`${id}_file`);
              if (!file) {
                throw new Error(`File '${id}_file' was not found`);
              }
              return file;
            }
            default:
              throw new Error(`Unknown reference value: ${input}`);
          }
        } else {
          throw new Error(`Invalid reference value: ${input}`);
        }
      }
      case "object": {
        if (input === null) {
          return null;
        } else if (Array.isArray(input)) {
          const arr = [];
          for (const item of input) {
            arr.push(deserizalizeValue(item));
          }
          return arr;
        } else if (isPlainObject(input)) {
          const obj = {};
          for (const [key, value2] of Object.entries(input)) {
            obj[key] = deserizalizeValue(value2);
          }
          return obj;
        } else {
          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);
        }
      }
      default:
        throw new Error(`Invalid value: ${input}`);
    }
  };
  return deserizalizeValue(baseValue);
}
function deserializeBuffer(tag, input, context) {
  const getBufferData = () => {
    const id = input.slice(2);
    const data = context.references.get(id);
    if (!data) {
      throw new Error(`Unable to get '${input}' buffer data`);
    }
    return JSON.parse(String(data));
  };
  switch (tag) {
    case "A" /* ArrayBuffer */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return bytes.buffer;
    }
    case "C" /* Int8Array */:
      return base64ToBuffer(getBufferData(), Int8Array);
    case "c" /* Uint8Array */:
      return base64ToBuffer(getBufferData(), Uint8Array);
    case "U" /* Uint8ClampedArray */:
      return base64ToBuffer(getBufferData(), Uint8ClampedArray);
    case "P" /* Int16Array */:
      return base64ToBuffer(getBufferData(), Int16Array);
    case "p" /* Uint16Array */:
      return base64ToBuffer(getBufferData(), Uint16Array);
    case "L" /* Int32Array */:
      return base64ToBuffer(getBufferData(), Int32Array);
    case "l" /* Uint32Array */:
      return base64ToBuffer(getBufferData(), Uint32Array);
    case "F" /* Float32Array */:
      return base64ToBuffer(getBufferData(), Float32Array);
    case "d" /* Float64Array */:
      return base64ToBuffer(getBufferData(), Float64Array);
    case "N" /* BigInt64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigInt64Array(bytes.buffer);
    }
    case "m" /* BigUint64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigUint64Array(bytes.buffer);
    }
    case "V" /* DataView */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new DataView(bytes.buffer);
    }
    default:
      throw new Error(`Unknown typed array buffer: ${input}`);
  }
}
export {
  decode,
  encode,
  encodeAsync
};
//# sourceMappingURL=index.js.map
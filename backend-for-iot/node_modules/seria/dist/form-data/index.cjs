"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/form-data/index.ts
var form_data_exports = {};
__export(form_data_exports, {
  decode: () => decode,
  encode: () => encode,
  encodeAsync: () => encodeAsync
});
module.exports = __toCommonJS(form_data_exports);

// src/tag.ts
var TYPED_ARRAY_TAGS = [
  "A" /* ArrayBuffer */,
  "C" /* Int8Array */,
  "c" /* Uint8Array */,
  "U" /* Uint8ClampedArray */,
  "P" /* Int16Array */,
  "p" /* Uint16Array */,
  "L" /* Int32Array */,
  "l" /* Uint32Array */,
  "F" /* Float32Array */,
  "d" /* Float64Array */,
  "N" /* BigInt64Array */,
  "m" /* BigUint64Array */,
  "V" /* DataView */
];
function isTypedArrayTag(tag) {
  return TYPED_ARRAY_TAGS.includes(tag);
}

// src/trackingPromise.ts
var TRACKING_PROMISE_SYMBOL = Symbol("TRACKING_PROMISE_SYMBOL");
function trackPromise(id, promise) {
  const tracking = Object.assign(promise, {
    id,
    status: { state: "pending" },
    [TRACKING_PROMISE_SYMBOL]: true
  });
  tracking.then((data) => {
    tracking.status = {
      state: "resolved",
      data
    };
  }).catch((error) => {
    tracking.status = {
      state: "rejected",
      error
    };
  });
  return tracking;
}

// src/utils.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function bufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64ToBuffer(base64String, Constructor) {
  const binaryString = atob(base64String);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return new Constructor(bytes.buffer);
}

// src/trackingAsyncIterable.ts
var TRACKING_ASYNC_ITERABLE_SYMBOL = Symbol("TRACKING_ASYNC_ITERABLE_SYMBOL");
function trackAsyncIterable(id, asyncIterator, context) {
  return Object.assign(asyncIterator, {
    id,
    context,
    [TRACKING_ASYNC_ITERABLE_SYMBOL]: true
  });
}

// src/json/stringify.ts
function internal_serialize(value, opts) {
  const { replacer, space, initialID = 1 } = opts;
  const writtenValues = /* @__PURE__ */ new Map();
  const pendingPromisesMap = /* @__PURE__ */ new Map();
  const pendingIteratorsMap = /* @__PURE__ */ new Map();
  const output = [];
  let id = initialID;
  const nextId = () => {
    return id++;
  };
  const checkWrittenValues = () => {
    for (const [id2, value2] of writtenValues) {
      output[id2] = value2;
    }
  };
  const context = {
    output,
    writtenValues,
    pendingPromisesMap,
    pendingIteratorsMap,
    space,
    nextId,
    encodeValue,
    checkWrittenValues
  };
  function encodeValue(input) {
    if (replacer) {
      const serialized = replacer(input, context);
      if (serialized !== void 0) {
        return serialized;
      }
    }
    switch (typeof input) {
      case "string":
        return `$$${input}`;
      case "boolean":
        return input;
      case "number":
        return serializeNumber(input);
      case "symbol":
        return serializeSymbol(input);
      case "undefined":
        return "$undefined";
      case "bigint":
        return serializeBigInt(input);
      case "object": {
        if (input === null) {
          return null;
        } else if (input instanceof Date) {
          return serializeDate(input);
        } else if (input instanceof Map) {
          return serializeMap(input, context);
        } else if (input instanceof Set) {
          return serializeSet(input, context);
        } else if (Array.isArray(input)) {
          return serializeArray(input, context);
        } else if (isPlainObject(input)) {
          return serializePlainObject(input, context);
        } else if (input instanceof Promise) {
          return serializePromise(input, context);
        } else if (isAsyncIterable(input)) {
          return serializeAsyncIterable(input, context);
        } else if (input instanceof ArrayBuffer) {
          return serializeArrayBuffer(input, context);
        } else if (input instanceof Int8Array) {
          return serializeTypedArray("C" /* Int8Array */, input, context);
        } else if (input instanceof Uint8Array) {
          return serializeTypedArray("c" /* Uint8Array */, input, context);
        } else if (input instanceof Uint8ClampedArray) {
          return serializeTypedArray("U" /* Uint8ClampedArray */, input, context);
        } else if (input instanceof Int16Array) {
          return serializeTypedArray("P" /* Int16Array */, input, context);
        } else if (input instanceof Uint16Array) {
          return serializeTypedArray("p" /* Uint16Array */, input, context);
        } else if (input instanceof Int32Array) {
          return serializeTypedArray("L" /* Int32Array */, input, context);
        } else if (input instanceof Uint32Array) {
          return serializeTypedArray("l" /* Uint32Array */, input, context);
        } else if (input instanceof Float32Array) {
          return serializeTypedArray("F" /* Float32Array */, input, context);
        } else if (input instanceof Float64Array) {
          return serializeTypedArray("d" /* Float64Array */, input, context);
        } else if (input instanceof BigInt64Array) {
          return serializeTypedArray("N" /* BigInt64Array */, input, context);
        } else if (input instanceof BigUint64Array) {
          return serializeTypedArray("m" /* BigUint64Array */, input, context);
        } else if (input instanceof DataView) {
          return serializeTypedArray("V" /* DataView */, input, context);
        } else {
          throw new Error(
            `Unable to serialize value: ${JSON.stringify(input)}`
          );
        }
      }
      case "function": {
        throw new Error("Functions cannot be serialized");
      }
      default:
        throw new Error(
          `Unreachable. Reaching this code should be considered a bug`
        );
    }
  }
  const baseValue = encodeValue(value);
  output[0] = baseValue;
  checkWrittenValues();
  return {
    output,
    get pendingPromises() {
      return Array.from(pendingPromisesMap.values());
    },
    get pendingIterators() {
      return Array.from(pendingIteratorsMap.values());
    }
  };
}
function serializeNumber(input) {
  if (Number.isFinite(input)) {
    if (input === 0 && 1 / input === -Infinity) {
      return serializeTagValue("-0" /* NegativeZero */);
    } else {
      return input;
    }
  } else {
    if (input === Infinity) {
      return serializeTagValue("Infinity" /* Infinity_ */);
    } else if (input === -Infinity) {
      return serializeTagValue("-Infinity" /* NegativeInfinity */);
    } else {
      return serializeTagValue("NaN" /* NaN_ */);
    }
  }
}
function serializeSymbol(input) {
  return serializeTagValue("S" /* Symbol */, input.description);
}
function serializeBigInt(input) {
  return serializeTagValue("n" /* BigInt */, String(input));
}
function serializeDate(input) {
  return serializeTagValue("D" /* Date */, input.toJSON());
}
function serializeArray(input, context) {
  const items = [];
  for (const val of input) {
    items.push(context.encodeValue(val));
  }
  return items;
}
function serializeSet(input, context) {
  const { writtenValues: referencesMap } = context;
  const items = [];
  for (const val of input) {
    items.push(context.encodeValue(val));
  }
  const id = context.nextId();
  referencesMap.set(id, items);
  return serializeTagValue("W" /* Set */, id);
}
function serializeMap(input, context) {
  const { writtenValues: referencesMap } = context;
  const items = [];
  for (const [k, v] of input) {
    const encodedKey = context.encodeValue(k);
    const encodedValue = context.encodeValue(v);
    items.push([encodedKey, encodedValue]);
  }
  const id = context.nextId();
  referencesMap.set(id, items);
  return serializeTagValue("Q" /* Map */, id);
}
function serializePlainObject(input, context) {
  const obj = {};
  for (const [key, value] of Object.entries(input)) {
    obj[key] = context.encodeValue(value);
  }
  return obj;
}
function serializePromise(input, context) {
  const id = context.nextId();
  const resolvingPromise = input.then((value) => {
    const ret = context.encodeValue(value);
    context.writtenValues.set(id, ret);
    context.checkWrittenValues();
    return value;
  });
  const trackingPromise = trackPromise(id, resolvingPromise);
  context.pendingPromisesMap.set(id, trackingPromise);
  return serializeTagValue("@" /* Promise */, id);
}
function serializeArrayBuffer(input, context) {
  return serializeTypedArray("A" /* ArrayBuffer */, new Uint8Array(input), context);
}
function serializeTypedArray(tag, input, context) {
  const id = context.nextId();
  const buffer = bufferToBase64(input.buffer);
  context.writtenValues.set(id, buffer);
  return serializeTagValue(tag, id);
}
function serializeAsyncIterable(input, context) {
  const id = context.nextId();
  async function* resolveAsyncIterable(iter) {
    for await (const item of iter) {
      if (isAsyncIterable(item)) {
        yield* resolveAsyncIterable(item);
      } else {
        yield item;
      }
    }
  }
  const generator = async function* () {
    for await (const item of resolveAsyncIterable(input)) {
      const ret = context.encodeValue(item);
      const items2 = [...context.output[id] || [], ret];
      context.writtenValues.set(id, items2);
      context.checkWrittenValues();
      yield ret;
    }
    const items = [...context.output[id] || [], "done"];
    context.writtenValues.set(id, items);
    context.checkWrittenValues();
    yield "done";
  }();
  const tracked = trackAsyncIterable(id, generator);
  context.pendingIteratorsMap.set(id, tracked);
  return serializeTagValue("#" /* AsyncIterator */, id);
}
function serializeTagValue(tag, value) {
  return value ? `$${tag}${value}` : `$${tag}`;
}
function isAsyncIterable(value) {
  return value != null && typeof value[Symbol.asyncIterator] === "function";
}

// src/form-data/index.ts
function encode(value, replacer) {
  const formData = new FormData();
  const { output, pendingPromises, pendingIterators } = internal_encodeFormData(
    value,
    {
      formData,
      replacer
    }
  );
  if (pendingPromises.length > 0) {
    throw new Error("Serialiation result have pending promises");
  }
  if (pendingIterators.length > 0) {
    throw new Error("Serialiation result have pending async iterators");
  }
  for (let i = 0; i < output.length; i++) {
    formData.set(String(i), JSON.stringify(output[i]));
  }
  return formData;
}
async function encodeAsync(value, replacer) {
  const formData = new FormData();
  const result = internal_encodeFormData(value, {
    formData,
    replacer
  });
  await Promise.all(result.pendingPromises);
  const iteratorPromises = result.pendingIterators.map(async (iter) => {
    for await (const _ of iter) {
    }
  });
  await Promise.all(iteratorPromises);
  for (let i = 0; i < result.output.length; i++) {
    formData.set(String(i), JSON.stringify(result.output[i]));
  }
  return formData;
}
function internal_encodeFormData(value, opts) {
  const { formData, replacer: _replacer } = opts;
  return internal_serialize(value, {
    replacer: (input, ctx) => {
      if (_replacer) {
        const ret = _replacer(input, ctx);
        if (ret !== void 0) {
          return ret;
        }
      }
      if (input instanceof FormData) {
        const id = ctx.nextId();
        for (const [key, entry] of input) {
          const fieldName = `${id}_${key}`;
          formData.set(fieldName, entry);
        }
        return serializeTagValue("K" /* FormData */, id);
      }
      if (input instanceof File) {
        const id = ctx.nextId();
        formData.set(`${id}_file`, input);
        return serializeTagValue("k" /* File */, id);
      }
      return void 0;
    }
  });
}
function decode(value, reviver, opts) {
  const { types } = opts || {};
  const { FormData: FormDataConstructor = globalThis.FormData } = types || {};
  const baseValue = function() {
    const entry = value.get("0");
    if (!entry) {
      throw new Error("Empty value to decode");
    }
    try {
      return JSON.parse(String(entry));
    } catch {
      throw new Error(`Failed to parse base value: ${entry}`);
    }
  }();
  const deserizalizeValue = (input) => {
    if (reviver) {
      const ret = reviver(input);
      if (ret !== void 0) {
        return ret;
      }
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input;
      case "string": {
        if (input[0] === "$") {
          const maybeTag = input.slice(1);
          switch (true) {
            case maybeTag[0] === "$" /* String */: {
              return input.slice(2);
            }
            case maybeTag[0] === "S" /* Symbol */: {
              return Symbol.for(input.slice(2));
            }
            case maybeTag[0] === "D" /* Date */: {
              return new Date(input.slice(2));
            }
            case maybeTag[0] === "n" /* BigInt */: {
              return BigInt(input.slice(2));
            }
            case maybeTag === "undefined" /* Undefined */: {
              return void 0;
            }
            case maybeTag === "Infinity" /* Infinity_ */: {
              return Infinity;
            }
            case maybeTag === "-Infinity" /* NegativeInfinity */: {
              return -Infinity;
            }
            case maybeTag === "-0" /* NegativeZero */: {
              return -0;
            }
            case maybeTag === "NaN" /* NaN_ */: {
              return NaN;
            }
            case maybeTag[0] === "W" /* Set */: {
              const id = input.slice(2);
              const set = /* @__PURE__ */ new Set();
              try {
                const values = value.get(id);
                if (values) {
                  const data = JSON.parse(String(values));
                  if (Array.isArray(data)) {
                    for (const item of data) {
                      set.add(deserizalizeValue(item));
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return set;
            }
            case maybeTag[0] === "Q" /* Map */: {
              const id = input.slice(2);
              const map = /* @__PURE__ */ new Map();
              try {
                const values = value.get(id);
                if (values) {
                  const data = JSON.parse(String(values));
                  if (Array.isArray(data)) {
                    for (const [key, value2] of data) {
                      const decodedKey = deserizalizeValue(key);
                      const decodedValue = deserizalizeValue(value2);
                      map.set(decodedKey, decodedValue);
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return map;
            }
            case maybeTag[0] === "@" /* Promise */: {
              const id = input.slice(2);
              const rawValue = value.get(id);
              if (!rawValue) {
                throw new Error("Failed to find promise resolved value");
              }
              try {
                const resolvedValue = deserizalizeValue(
                  JSON.parse(String(rawValue))
                );
                return Promise.resolve(resolvedValue);
              } catch {
                throw new Error("Unable to resolve promise value");
              }
            }
            case maybeTag[0] === "#" /* AsyncIterator */: {
              const id = input.slice(2);
              const json = value.get(id);
              if (!json) {
                throw new Error(`Unable to get async iterator '${id}'`);
              }
              const asyncIteratorValues = JSON.parse(String(json));
              if (Array.isArray(asyncIteratorValues)) {
                const length = asyncIteratorValues.length - 1;
                const isDone = asyncIteratorValues[length] === "done";
                const values = isDone ? asyncIteratorValues.slice(0, -1) : asyncIteratorValues;
                const generator = async function* () {
                  for (const item of values) {
                    const resolvedValue = deserizalizeValue(item);
                    yield resolvedValue;
                  }
                }();
                return generator;
              } else {
                throw new Error(
                  "Failed to parse async iterator, expected array of values"
                );
              }
            }
            case maybeTag[0] === "K" /* FormData */: {
              const formData = new FormDataConstructor();
              const id = input.slice(2);
              value.forEach((entry, key) => {
                const entryKey = `${id}_`;
                if (key.startsWith(entryKey)) {
                  const fieldName = key.slice(entryKey.length);
                  formData.set(fieldName, entry);
                }
              });
              return formData;
            }
            case isTypedArrayTag(maybeTag[0]): {
              return deserializeBuffer(maybeTag[0], input, {
                references: value
              });
            }
            case maybeTag[0] === "k" /* File */: {
              const id = input.slice(2);
              const file = value.get(`${id}_file`);
              if (!file) {
                throw new Error(`File '${id}_file' was not found`);
              }
              return file;
            }
            default:
              throw new Error(`Unknown reference value: ${input}`);
          }
        } else {
          throw new Error(`Invalid reference value: ${input}`);
        }
      }
      case "object": {
        if (input === null) {
          return null;
        } else if (Array.isArray(input)) {
          const arr = [];
          for (const item of input) {
            arr.push(deserizalizeValue(item));
          }
          return arr;
        } else if (isPlainObject(input)) {
          const obj = {};
          for (const [key, value2] of Object.entries(input)) {
            obj[key] = deserizalizeValue(value2);
          }
          return obj;
        } else {
          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);
        }
      }
      default:
        throw new Error(`Invalid value: ${input}`);
    }
  };
  return deserizalizeValue(baseValue);
}
function deserializeBuffer(tag, input, context) {
  const getBufferData = () => {
    const id = input.slice(2);
    const data = context.references.get(id);
    if (!data) {
      throw new Error(`Unable to get '${input}' buffer data`);
    }
    return JSON.parse(String(data));
  };
  switch (tag) {
    case "A" /* ArrayBuffer */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return bytes.buffer;
    }
    case "C" /* Int8Array */:
      return base64ToBuffer(getBufferData(), Int8Array);
    case "c" /* Uint8Array */:
      return base64ToBuffer(getBufferData(), Uint8Array);
    case "U" /* Uint8ClampedArray */:
      return base64ToBuffer(getBufferData(), Uint8ClampedArray);
    case "P" /* Int16Array */:
      return base64ToBuffer(getBufferData(), Int16Array);
    case "p" /* Uint16Array */:
      return base64ToBuffer(getBufferData(), Uint16Array);
    case "L" /* Int32Array */:
      return base64ToBuffer(getBufferData(), Int32Array);
    case "l" /* Uint32Array */:
      return base64ToBuffer(getBufferData(), Uint32Array);
    case "F" /* Float32Array */:
      return base64ToBuffer(getBufferData(), Float32Array);
    case "d" /* Float64Array */:
      return base64ToBuffer(getBufferData(), Float64Array);
    case "N" /* BigInt64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigInt64Array(bytes.buffer);
    }
    case "m" /* BigUint64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigUint64Array(bytes.buffer);
    }
    case "V" /* DataView */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new DataView(bytes.buffer);
    }
    default:
      throw new Error(`Unknown typed array buffer: ${input}`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decode,
  encode,
  encodeAsync
});
//# sourceMappingURL=index.cjs.map
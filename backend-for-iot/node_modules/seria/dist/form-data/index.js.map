{"version":3,"sources":["../../src/form-data/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport { Tag, isTypedArrayTag } from \"../tag\";\r\nimport {\r\n  type Replacer,\r\n  internal_serialize,\r\n  serializeTagValue,\r\n} from \"../json/stringify\";\r\nimport { type Reviver } from \"../json/parse\";\r\nimport { isPlainObject } from \"../utils\";\r\nimport { base64ToBuffer } from \"../utils\";\r\n\r\n// The browser `FormData` is assignable to this one\r\nimport type { FormData as UndiciFormData } from \"undici\";\r\n\r\n/**\r\n * Encodes a value into a `FormData`.\r\n * @param value The value to encode.\r\n * @param replacer Converts a value to string.\r\n * @returns The value encoded as `FormData`.\r\n * @throws If the value is or have any promise.\r\n */\r\nexport function encode(value: unknown, replacer?: Replacer): FormData {\r\n  const formData = new FormData();\r\n  const { output, pendingPromises, pendingIterators } = internal_encodeFormData(\r\n    value,\r\n    {\r\n      formData,\r\n      replacer,\r\n    }\r\n  );\r\n\r\n  if (pendingPromises.length > 0) {\r\n    throw new Error(\"Serialiation result have pending promises\");\r\n  }\r\n\r\n  if (pendingIterators.length > 0) {\r\n    throw new Error(\"Serialiation result have pending async iterators\");\r\n  }\r\n\r\n  for (let i = 0; i < output.length; i++) {\r\n    formData.set(String(i), JSON.stringify(output[i]));\r\n  }\r\n\r\n  return formData;\r\n}\r\n\r\n/**\r\n * Encodes a value into a `FormData`, resolving all it's promises if any.\r\n * @param value The value to encode.\r\n * @param replacer Converts a value to string.\r\n * @returns The value encoded as `FormData`.\r\n */\r\nexport async function encodeAsync(\r\n  value: unknown,\r\n  replacer?: Replacer\r\n): Promise<FormData> {\r\n  const formData = new FormData();\r\n  const result = internal_encodeFormData(value, {\r\n    formData,\r\n    replacer,\r\n  });\r\n\r\n  await Promise.all(result.pendingPromises);\r\n\r\n  // Then we drain all the values on the async iterators\r\n  const iteratorPromises = result.pendingIterators.map(async (iter) => {\r\n    for await (const _ of iter) {\r\n      // nothing\r\n    }\r\n  });\r\n\r\n  await Promise.all(iteratorPromises);\r\n\r\n  for (let i = 0; i < result.output.length; i++) {\r\n    formData.set(String(i), JSON.stringify(result.output[i]));\r\n  }\r\n\r\n  return formData;\r\n}\r\n\r\nfunction internal_encodeFormData(\r\n  value: unknown,\r\n  opts: {\r\n    formData: FormData;\r\n    replacer?: Replacer;\r\n  }\r\n) {\r\n  const { formData, replacer: _replacer } = opts;\r\n  return internal_serialize(value, {\r\n    replacer: (input, ctx) => {\r\n      if (_replacer) {\r\n        const ret = _replacer(input, ctx);\r\n        if (ret !== undefined) {\r\n          return ret;\r\n        }\r\n      }\r\n\r\n      if (input instanceof FormData) {\r\n        const id = ctx.nextId();\r\n\r\n        for (const [key, entry] of input) {\r\n          const fieldName = `${id}_${key}`;\r\n          formData.set(fieldName, entry);\r\n        }\r\n\r\n        return serializeTagValue(Tag.FormData, id);\r\n      }\r\n\r\n      if (input instanceof File) {\r\n        const id = ctx.nextId();\r\n        formData.set(`${id}_file`, input);\r\n        return serializeTagValue(Tag.File, id);\r\n      }\r\n\r\n      return undefined;\r\n    },\r\n  });\r\n}\r\n\r\n// Inspired on: https://github.com/facebook/react/blob/1293047d6063f3508af15e68cca916660ded791e/packages/react-server/src/ReactFlightReplyServer.js#L379-L380\r\n\r\ntype DecodeContext = {\r\n  references: FormData;\r\n};\r\n\r\ntype DecodeOptions = {\r\n  /**\r\n   * Custom type constructors to use.\r\n   */\r\n  types?: {\r\n    /**\r\n     * `FormData` constructor, this defaults to `globalThis.FormData`.\r\n     */\r\n    FormData: typeof UndiciFormData;\r\n  };\r\n};\r\n\r\n/**\r\n * Decode a `FormData` into a value.\r\n * @param value The formData to decode.\r\n * @param reviver Converts a value.\r\n * @returns The decoded value.\r\n */\r\nexport function decode(\r\n  value: FormData,\r\n  reviver?: Reviver | null,\r\n  opts?: DecodeOptions\r\n): unknown {\r\n  const { types } = opts || {};\r\n  const { FormData: FormDataConstructor = globalThis.FormData } = types || {};\r\n\r\n  const baseValue = (function () {\r\n    const entry = value.get(\"0\");\r\n\r\n    if (!entry) {\r\n      throw new Error(\"Empty value to decode\");\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(String(entry));\r\n    } catch {\r\n      throw new Error(`Failed to parse base value: ${entry}`);\r\n    }\r\n  })();\r\n\r\n  const deserizalizeValue = (input: any): unknown => {\r\n    if (reviver) {\r\n      const ret = reviver(input);\r\n      if (ret !== undefined) {\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    switch (typeof input) {\r\n      case \"number\":\r\n        return input;\r\n      case \"boolean\":\r\n        return input;\r\n      case \"string\": {\r\n        if (input[0] === \"$\") {\r\n          const maybeTag = input.slice(1);\r\n\r\n          switch (true) {\r\n            case maybeTag[0] === Tag.String: {\r\n              return input.slice(2);\r\n            }\r\n            case maybeTag[0] === Tag.Symbol: {\r\n              return Symbol.for(input.slice(2));\r\n            }\r\n            case maybeTag[0] === Tag.Date: {\r\n              return new Date(input.slice(2));\r\n            }\r\n            case maybeTag[0] === Tag.BigInt: {\r\n              return BigInt(input.slice(2));\r\n            }\r\n            case maybeTag === Tag.Undefined: {\r\n              return undefined;\r\n            }\r\n            case maybeTag === Tag.Infinity_: {\r\n              return Infinity;\r\n            }\r\n            case maybeTag === Tag.NegativeInfinity: {\r\n              return -Infinity;\r\n            }\r\n            case maybeTag === Tag.NegativeZero: {\r\n              return -0;\r\n            }\r\n            case maybeTag === Tag.NaN_: {\r\n              return NaN;\r\n            }\r\n            case maybeTag[0] === Tag.Set: {\r\n              const id = input.slice(2);\r\n              const set = new Set<any>();\r\n\r\n              try {\r\n                const values = value.get(id);\r\n                if (values) {\r\n                  const data = JSON.parse(String(values)); // This is stored as an Array<string>\r\n                  if (Array.isArray(data)) {\r\n                    for (const item of data) {\r\n                      set.add(deserizalizeValue(item));\r\n                    }\r\n                  }\r\n                }\r\n              } catch (err) {\r\n                // failed to parse\r\n                console.error(err);\r\n              }\r\n\r\n              return set;\r\n            }\r\n            case maybeTag[0] === Tag.Map: {\r\n              const id = input.slice(2);\r\n              const map = new Map<any, any>();\r\n\r\n              try {\r\n                const values = value.get(id);\r\n                if (values) {\r\n                  const data = JSON.parse(String(values)); // This is stored as an Array<[string, string]>\r\n                  if (Array.isArray(data)) {\r\n                    for (const [key, value] of data) {\r\n                      const decodedKey = deserizalizeValue(key);\r\n                      const decodedValue = deserizalizeValue(value);\r\n                      map.set(decodedKey, decodedValue);\r\n                    }\r\n                  }\r\n                }\r\n              } catch (err) {\r\n                // failed to parse\r\n                console.error(err);\r\n              }\r\n\r\n              return map;\r\n            }\r\n            case maybeTag[0] === Tag.Promise: {\r\n              const id = input.slice(2);\r\n              const rawValue = value.get(id);\r\n\r\n              if (!rawValue) {\r\n                throw new Error(\"Failed to find promise resolved value\");\r\n              }\r\n\r\n              try {\r\n                const resolvedValue = deserizalizeValue(\r\n                  JSON.parse(String(rawValue))\r\n                );\r\n                return Promise.resolve(resolvedValue);\r\n              } catch {\r\n                throw new Error(\"Unable to resolve promise value\");\r\n              }\r\n            }\r\n            case maybeTag[0] === Tag.AsyncIterator: {\r\n              const id = input.slice(2);\r\n              const json = value.get(id);\r\n\r\n              if (!json) {\r\n                throw new Error(`Unable to get async iterator '${id}'`);\r\n              }\r\n\r\n              const asyncIteratorValues = JSON.parse(String(json));\r\n\r\n              if (Array.isArray(asyncIteratorValues)) {\r\n                const length = asyncIteratorValues.length - 1;\r\n                const isDone = asyncIteratorValues[length] === \"done\";\r\n\r\n                const values = isDone\r\n                  ? asyncIteratorValues.slice(0, -1)\r\n                  : asyncIteratorValues;\r\n\r\n                const generator = (async function* () {\r\n                  for (const item of values) {\r\n                    const resolvedValue = deserizalizeValue(item);\r\n                    yield resolvedValue;\r\n                  }\r\n                })();\r\n\r\n                return generator;\r\n              } else {\r\n                throw new Error(\r\n                  \"Failed to parse async iterator, expected array of values\"\r\n                );\r\n              }\r\n            }\r\n            case maybeTag[0] === Tag.FormData: {\r\n              const formData = new FormDataConstructor();\r\n              const id = input.slice(2);\r\n\r\n              value.forEach((entry, key) => {\r\n                const entryKey = `${id}_`;\r\n                if (key.startsWith(entryKey)) {\r\n                  const fieldName = key.slice(entryKey.length);\r\n                  formData.set(fieldName, entry);\r\n                }\r\n              });\r\n\r\n              return formData;\r\n            }\r\n            case isTypedArrayTag(maybeTag[0]): {\r\n              return deserializeBuffer(maybeTag[0], input, {\r\n                references: value,\r\n              });\r\n            }\r\n            case maybeTag[0] === Tag.File: {\r\n              const id = input.slice(2);\r\n              const file = value.get(`${id}_file`);\r\n\r\n              if (!file) {\r\n                throw new Error(`File '${id}_file' was not found`);\r\n              }\r\n\r\n              return file;\r\n            }\r\n            default:\r\n              throw new Error(`Unknown reference value: ${input}`);\r\n          }\r\n        } else {\r\n          throw new Error(`Invalid reference value: ${input}`);\r\n        }\r\n      }\r\n      case \"object\": {\r\n        if (input === null) {\r\n          return null;\r\n        } else if (Array.isArray(input)) {\r\n          const arr: any[] = [];\r\n          for (const item of input) {\r\n            arr.push(deserizalizeValue(item));\r\n          }\r\n          return arr;\r\n        } else if (isPlainObject(input)) {\r\n          const obj: Record<string, unknown> = {};\r\n\r\n          for (const [key, value] of Object.entries(input)) {\r\n            obj[key] = deserizalizeValue(value);\r\n          }\r\n\r\n          return obj;\r\n        } else {\r\n          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);\r\n        }\r\n      }\r\n      default:\r\n        throw new Error(`Invalid value: ${input}`);\r\n    }\r\n  };\r\n\r\n  return deserizalizeValue(baseValue);\r\n}\r\n\r\nfunction deserializeBuffer(tag: Tag, input: string, context: DecodeContext) {\r\n  const getBufferData = () => {\r\n    const id = input.slice(2);\r\n    const data = context.references.get(id);\r\n    if (!data) {\r\n      throw new Error(`Unable to get '${input}' buffer data`);\r\n    }\r\n    return JSON.parse(String(data));\r\n  };\r\n\r\n  switch (tag) {\r\n    case Tag.ArrayBuffer: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return bytes.buffer;\r\n    }\r\n    case Tag.Int8Array:\r\n      return base64ToBuffer(getBufferData(), Int8Array);\r\n    case Tag.Uint8Array:\r\n      return base64ToBuffer(getBufferData(), Uint8Array);\r\n    case Tag.Uint8ClampedArray:\r\n      return base64ToBuffer(getBufferData(), Uint8ClampedArray);\r\n    case Tag.Int16Array:\r\n      return base64ToBuffer(getBufferData(), Int16Array);\r\n    case Tag.Uint16Array:\r\n      return base64ToBuffer(getBufferData(), Uint16Array);\r\n    case Tag.Int32Array:\r\n      return base64ToBuffer(getBufferData(), Int32Array);\r\n    case Tag.Uint32Array:\r\n      return base64ToBuffer(getBufferData(), Uint32Array);\r\n    case Tag.Float32Array:\r\n      return base64ToBuffer(getBufferData(), Float32Array);\r\n    case Tag.Float64Array:\r\n      return base64ToBuffer(getBufferData(), Float64Array);\r\n    case Tag.BigInt64Array: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new BigInt64Array(bytes.buffer);\r\n    }\r\n    case Tag.BigUint64Array: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new BigUint64Array(bytes.buffer);\r\n    }\r\n    case Tag.DataView: {\r\n      const bytes = base64ToBuffer(getBufferData(), Uint8Array);\r\n      return new DataView(bytes.buffer);\r\n    }\r\n    default:\r\n      throw new Error(`Unknown typed array buffer: ${input}`);\r\n  }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;AAsBO,SAAS,OAAO,OAAgB,UAA+B;AACpE,QAAM,WAAW,IAAI,SAAS;AAC9B,QAAM,EAAE,QAAQ,iBAAiB,iBAAiB,IAAI;AAAA,IACpD;AAAA,IACA;AAAA,MACE;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,MAAI,gBAAgB,SAAS,GAAG;AAC9B,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC7D;AAEA,MAAI,iBAAiB,SAAS,GAAG;AAC/B,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACpE;AAEA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,aAAS,IAAI,OAAO,CAAC,GAAG,KAAK,UAAU,OAAO,CAAC,CAAC,CAAC;AAAA,EACnD;AAEA,SAAO;AACT;AAQA,eAAsB,YACpB,OACA,UACmB;AACnB,QAAM,WAAW,IAAI,SAAS;AAC9B,QAAM,SAAS,wBAAwB,OAAO;AAAA,IAC5C;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAM,QAAQ,IAAI,OAAO,eAAe;AAGxC,QAAM,mBAAmB,OAAO,iBAAiB,IAAI,OAAO,SAAS;AACnE,qBAAiB,KAAK,MAAM;AAAA,IAE5B;AAAA,EACF,CAAC;AAED,QAAM,QAAQ,IAAI,gBAAgB;AAElC,WAAS,IAAI,GAAG,IAAI,OAAO,OAAO,QAAQ,KAAK;AAC7C,aAAS,IAAI,OAAO,CAAC,GAAG,KAAK,UAAU,OAAO,OAAO,CAAC,CAAC,CAAC;AAAA,EAC1D;AAEA,SAAO;AACT;AAEA,SAAS,wBACP,OACA,MAIA;AACA,QAAM,EAAE,UAAU,UAAU,UAAU,IAAI;AAC1C,SAAO,mBAAmB,OAAO;AAAA,IAC/B,UAAU,CAAC,OAAO,QAAQ;AACxB,UAAI,WAAW;AACb,cAAM,MAAM,UAAU,OAAO,GAAG;AAChC,YAAI,QAAQ,QAAW;AACrB,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,UAAI,iBAAiB,UAAU;AAC7B,cAAM,KAAK,IAAI,OAAO;AAEtB,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO;AAChC,gBAAM,YAAY,GAAG,EAAE,IAAI,GAAG;AAC9B,mBAAS,IAAI,WAAW,KAAK;AAAA,QAC/B;AAEA,eAAO,sCAAgC,EAAE;AAAA,MAC3C;AAEA,UAAI,iBAAiB,MAAM;AACzB,cAAM,KAAK,IAAI,OAAO;AACtB,iBAAS,IAAI,GAAG,EAAE,SAAS,KAAK;AAChC,eAAO,kCAA4B,EAAE;AAAA,MACvC;AAEA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH;AA0BO,SAAS,OACd,OACA,SACA,MACS;AACT,QAAM,EAAE,MAAM,IAAI,QAAQ,CAAC;AAC3B,QAAM,EAAE,UAAU,sBAAsB,WAAW,SAAS,IAAI,SAAS,CAAC;AAE1E,QAAM,YAAa,WAAY;AAC7B,UAAM,QAAQ,MAAM,IAAI,GAAG;AAE3B,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAEA,QAAI;AACF,aAAO,KAAK,MAAM,OAAO,KAAK,CAAC;AAAA,IACjC,QAAQ;AACN,YAAM,IAAI,MAAM,+BAA+B,KAAK,EAAE;AAAA,IACxD;AAAA,EACF,EAAG;AAEH,QAAM,oBAAoB,CAAC,UAAwB;AACjD,QAAI,SAAS;AACX,YAAM,MAAM,QAAQ,KAAK;AACzB,UAAI,QAAQ,QAAW;AACrB,eAAO;AAAA,MACT;AAAA,IACF;AAEA,YAAQ,OAAO,OAAO;AAAA,MACpB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK,UAAU;AACb,YAAI,MAAM,CAAC,MAAM,KAAK;AACpB,gBAAM,WAAW,MAAM,MAAM,CAAC;AAE9B,kBAAQ,MAAM;AAAA,YACZ,KAAK,SAAS,CAAC,wBAAkB;AAC/B,qBAAO,MAAM,MAAM,CAAC;AAAA,YACtB;AAAA,YACA,KAAK,SAAS,CAAC,wBAAkB;AAC/B,qBAAO,OAAO,IAAI,MAAM,MAAM,CAAC,CAAC;AAAA,YAClC;AAAA,YACA,KAAK,SAAS,CAAC,sBAAgB;AAC7B,qBAAO,IAAI,KAAK,MAAM,MAAM,CAAC,CAAC;AAAA,YAChC;AAAA,YACA,KAAK,SAAS,CAAC,wBAAkB;AAC/B,qBAAO,OAAO,MAAM,MAAM,CAAC,CAAC;AAAA,YAC9B;AAAA,YACA,KAAK,0CAA4B;AAC/B,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,yCAA4B;AAC/B,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,iDAAmC;AACtC,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,sCAA+B;AAClC,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,+BAAuB;AAC1B,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,SAAS,CAAC,qBAAe;AAC5B,oBAAM,KAAK,MAAM,MAAM,CAAC;AACxB,oBAAM,MAAM,oBAAI,IAAS;AAEzB,kBAAI;AACF,sBAAM,SAAS,MAAM,IAAI,EAAE;AAC3B,oBAAI,QAAQ;AACV,wBAAM,OAAO,KAAK,MAAM,OAAO,MAAM,CAAC;AACtC,sBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,+BAAW,QAAQ,MAAM;AACvB,0BAAI,IAAI,kBAAkB,IAAI,CAAC;AAAA,oBACjC;AAAA,kBACF;AAAA,gBACF;AAAA,cACF,SAAS,KAAK;AAEZ,wBAAQ,MAAM,GAAG;AAAA,cACnB;AAEA,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,SAAS,CAAC,qBAAe;AAC5B,oBAAM,KAAK,MAAM,MAAM,CAAC;AACxB,oBAAM,MAAM,oBAAI,IAAc;AAE9B,kBAAI;AACF,sBAAM,SAAS,MAAM,IAAI,EAAE;AAC3B,oBAAI,QAAQ;AACV,wBAAM,OAAO,KAAK,MAAM,OAAO,MAAM,CAAC;AACtC,sBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,+BAAW,CAAC,KAAKA,MAAK,KAAK,MAAM;AAC/B,4BAAM,aAAa,kBAAkB,GAAG;AACxC,4BAAM,eAAe,kBAAkBA,MAAK;AAC5C,0BAAI,IAAI,YAAY,YAAY;AAAA,oBAClC;AAAA,kBACF;AAAA,gBACF;AAAA,cACF,SAAS,KAAK;AAEZ,wBAAQ,MAAM,GAAG;AAAA,cACnB;AAEA,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,SAAS,CAAC,yBAAmB;AAChC,oBAAM,KAAK,MAAM,MAAM,CAAC;AACxB,oBAAM,WAAW,MAAM,IAAI,EAAE;AAE7B,kBAAI,CAAC,UAAU;AACb,sBAAM,IAAI,MAAM,uCAAuC;AAAA,cACzD;AAEA,kBAAI;AACF,sBAAM,gBAAgB;AAAA,kBACpB,KAAK,MAAM,OAAO,QAAQ,CAAC;AAAA,gBAC7B;AACA,uBAAO,QAAQ,QAAQ,aAAa;AAAA,cACtC,QAAQ;AACN,sBAAM,IAAI,MAAM,iCAAiC;AAAA,cACnD;AAAA,YACF;AAAA,YACA,KAAK,SAAS,CAAC,+BAAyB;AACtC,oBAAM,KAAK,MAAM,MAAM,CAAC;AACxB,oBAAM,OAAO,MAAM,IAAI,EAAE;AAEzB,kBAAI,CAAC,MAAM;AACT,sBAAM,IAAI,MAAM,iCAAiC,EAAE,GAAG;AAAA,cACxD;AAEA,oBAAM,sBAAsB,KAAK,MAAM,OAAO,IAAI,CAAC;AAEnD,kBAAI,MAAM,QAAQ,mBAAmB,GAAG;AACtC,sBAAM,SAAS,oBAAoB,SAAS;AAC5C,sBAAM,SAAS,oBAAoB,MAAM,MAAM;AAE/C,sBAAM,SAAS,SACX,oBAAoB,MAAM,GAAG,EAAE,IAC/B;AAEJ,sBAAM,YAAa,mBAAmB;AACpC,6BAAW,QAAQ,QAAQ;AACzB,0BAAM,gBAAgB,kBAAkB,IAAI;AAC5C,0BAAM;AAAA,kBACR;AAAA,gBACF,EAAG;AAEH,uBAAO;AAAA,cACT,OAAO;AACL,sBAAM,IAAI;AAAA,kBACR;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,YACA,KAAK,SAAS,CAAC,0BAAoB;AACjC,oBAAM,WAAW,IAAI,oBAAoB;AACzC,oBAAM,KAAK,MAAM,MAAM,CAAC;AAExB,oBAAM,QAAQ,CAAC,OAAO,QAAQ;AAC5B,sBAAM,WAAW,GAAG,EAAE;AACtB,oBAAI,IAAI,WAAW,QAAQ,GAAG;AAC5B,wBAAM,YAAY,IAAI,MAAM,SAAS,MAAM;AAC3C,2BAAS,IAAI,WAAW,KAAK;AAAA,gBAC/B;AAAA,cACF,CAAC;AAED,qBAAO;AAAA,YACT;AAAA,YACA,KAAK,gBAAgB,SAAS,CAAC,CAAC,GAAG;AACjC,qBAAO,kBAAkB,SAAS,CAAC,GAAG,OAAO;AAAA,gBAC3C,YAAY;AAAA,cACd,CAAC;AAAA,YACH;AAAA,YACA,KAAK,SAAS,CAAC,sBAAgB;AAC7B,oBAAM,KAAK,MAAM,MAAM,CAAC;AACxB,oBAAM,OAAO,MAAM,IAAI,GAAG,EAAE,OAAO;AAEnC,kBAAI,CAAC,MAAM;AACT,sBAAM,IAAI,MAAM,SAAS,EAAE,sBAAsB;AAAA,cACnD;AAEA,qBAAO;AAAA,YACT;AAAA,YACA;AACE,oBAAM,IAAI,MAAM,4BAA4B,KAAK,EAAE;AAAA,UACvD;AAAA,QACF,OAAO;AACL,gBAAM,IAAI,MAAM,4BAA4B,KAAK,EAAE;AAAA,QACrD;AAAA,MACF;AAAA,MACA,KAAK,UAAU;AACb,YAAI,UAAU,MAAM;AAClB,iBAAO;AAAA,QACT,WAAW,MAAM,QAAQ,KAAK,GAAG;AAC/B,gBAAM,MAAa,CAAC;AACpB,qBAAW,QAAQ,OAAO;AACxB,gBAAI,KAAK,kBAAkB,IAAI,CAAC;AAAA,UAClC;AACA,iBAAO;AAAA,QACT,WAAW,cAAc,KAAK,GAAG;AAC/B,gBAAM,MAA+B,CAAC;AAEtC,qBAAW,CAAC,KAAKA,MAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAChD,gBAAI,GAAG,IAAI,kBAAkBA,MAAK;AAAA,UACpC;AAEA,iBAAO;AAAA,QACT,OAAO;AACL,gBAAM,IAAI,MAAM,yBAAyB,KAAK,UAAU,KAAK,CAAC,EAAE;AAAA,QAClE;AAAA,MACF;AAAA,MACA;AACE,cAAM,IAAI,MAAM,kBAAkB,KAAK,EAAE;AAAA,IAC7C;AAAA,EACF;AAEA,SAAO,kBAAkB,SAAS;AACpC;AAEA,SAAS,kBAAkB,KAAU,OAAe,SAAwB;AAC1E,QAAM,gBAAgB,MAAM;AAC1B,UAAM,KAAK,MAAM,MAAM,CAAC;AACxB,UAAM,OAAO,QAAQ,WAAW,IAAI,EAAE;AACtC,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,kBAAkB,KAAK,eAAe;AAAA,IACxD;AACA,WAAO,KAAK,MAAM,OAAO,IAAI,CAAC;AAAA,EAChC;AAEA,UAAQ,KAAK;AAAA,IACX,4BAAsB;AACpB,YAAM,QAAQ,eAAe,cAAc,GAAG,UAAU;AACxD,aAAO,MAAM;AAAA,IACf;AAAA,IACA;AACE,aAAO,eAAe,cAAc,GAAG,SAAS;AAAA,IAClD;AACE,aAAO,eAAe,cAAc,GAAG,UAAU;AAAA,IACnD;AACE,aAAO,eAAe,cAAc,GAAG,iBAAiB;AAAA,IAC1D;AACE,aAAO,eAAe,cAAc,GAAG,UAAU;AAAA,IACnD;AACE,aAAO,eAAe,cAAc,GAAG,WAAW;AAAA,IACpD;AACE,aAAO,eAAe,cAAc,GAAG,UAAU;AAAA,IACnD;AACE,aAAO,eAAe,cAAc,GAAG,WAAW;AAAA,IACpD;AACE,aAAO,eAAe,cAAc,GAAG,YAAY;AAAA,IACrD;AACE,aAAO,eAAe,cAAc,GAAG,YAAY;AAAA,IACrD,8BAAwB;AACtB,YAAM,QAAQ,eAAe,cAAc,GAAG,UAAU;AACxD,aAAO,IAAI,cAAc,MAAM,MAAM;AAAA,IACvC;AAAA,IACA,+BAAyB;AACvB,YAAM,QAAQ,eAAe,cAAc,GAAG,UAAU;AACxD,aAAO,IAAI,eAAe,MAAM,MAAM;AAAA,IACxC;AAAA,IACA,yBAAmB;AACjB,YAAM,QAAQ,eAAe,cAAc,GAAG,UAAU;AACxD,aAAO,IAAI,SAAS,MAAM,MAAM;AAAA,IAClC;AAAA,IACA;AACE,YAAM,IAAI,MAAM,+BAA+B,KAAK,EAAE;AAAA,EAC1D;AACF;","names":["value"]}
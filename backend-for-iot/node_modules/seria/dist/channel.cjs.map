{"version":3,"sources":["../src/channel.ts"],"sourcesContent":["export type Sender<T> = {\r\n  id: number;\r\n  send: (value: T | Promise<T>) => void;\r\n  close: () => void;\r\n};\r\n\r\nexport type Receiver<T> = {\r\n  id: number;\r\n  recv: () => Promise<T | undefined>;\r\n  next: () => Promise<IteratorResult<T | undefined>>;\r\n  isClosed: () => boolean;\r\n  [Symbol.asyncIterator]: () => AsyncIterator<T>;\r\n};\r\n\r\ntype ChannelOptions = {\r\n  id: number;\r\n};\r\n\r\ntype ResolvePromise<T> = (value: T | Promise<T> | undefined) => void;\r\n\r\n/**\r\n * Create a multi-producer and single consumer channel.\r\n * @param options Options used to create the channel.\r\n * @returns A tuple with the sender and receiver.\r\n */\r\nexport function createChannel<T>(options: ChannelOptions) {\r\n  const { id } = options;\r\n  const queue: Promise<T>[] = [];\r\n  const resolveQueue: ResolvePromise<T>[] = [];\r\n  let closed = false;\r\n\r\n  function send(value: T | Promise<T>) {\r\n    if (closed) {\r\n      throw new Error(\"Channel was closed\");\r\n    }\r\n\r\n    const promise = value instanceof Promise ? value : Promise.resolve(value);\r\n    const resolve = resolveQueue.shift();\r\n\r\n    if (resolve) {\r\n      resolve(promise);\r\n    } else {\r\n      queue.push(promise);\r\n    }\r\n  }\r\n\r\n  async function recv() {\r\n    if (closed && queue.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    const promise = queue.shift();\r\n\r\n    if (promise) {\r\n      return promise;\r\n    }\r\n\r\n    return new Promise<T | undefined>((resolve) => {\r\n      resolveQueue.push(resolve);\r\n    });\r\n  }\r\n\r\n  async function* asyncIterator() {\r\n    while (true) {\r\n      const item = await recv();\r\n\r\n      if (item === undefined) {\r\n        break;\r\n      }\r\n\r\n      yield item;\r\n    }\r\n  }\r\n\r\n  async function next(): Promise<IteratorResult<T | undefined>> {\r\n    const value = await recv();\r\n    return { done: closed, value };\r\n  }\r\n\r\n  const sender: Sender<T> = {\r\n    id,\r\n    send,\r\n    close: () => {\r\n      closed = true;\r\n\r\n      // resolve each pending with undefined\r\n      const pendingResolve = resolveQueue.splice(0, resolveQueue.length);\r\n      for (const resolve of pendingResolve) {\r\n        resolve(undefined);\r\n      }\r\n    },\r\n  };\r\n\r\n  const receiver: Receiver<T> = {\r\n    id,\r\n    recv,\r\n    next,\r\n    isClosed: () => closed,\r\n    [Symbol.asyncIterator]: asyncIterator,\r\n  };\r\n\r\n  return [sender, receiver] as const;\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBO,SAAS,cAAiB,SAAyB;AACxD,QAAM,EAAE,GAAG,IAAI;AACf,QAAM,QAAsB,CAAC;AAC7B,QAAM,eAAoC,CAAC;AAC3C,MAAI,SAAS;AAEb,WAAS,KAAK,OAAuB;AACnC,QAAI,QAAQ;AACV,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACtC;AAEA,UAAM,UAAU,iBAAiB,UAAU,QAAQ,QAAQ,QAAQ,KAAK;AACxE,UAAM,UAAU,aAAa,MAAM;AAEnC,QAAI,SAAS;AACX,cAAQ,OAAO;AAAA,IACjB,OAAO;AACL,YAAM,KAAK,OAAO;AAAA,IACpB;AAAA,EACF;AAEA,iBAAe,OAAO;AACpB,QAAI,UAAU,MAAM,WAAW,GAAG;AAChC,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,MAAM,MAAM;AAE5B,QAAI,SAAS;AACX,aAAO;AAAA,IACT;AAEA,WAAO,IAAI,QAAuB,CAAC,YAAY;AAC7C,mBAAa,KAAK,OAAO;AAAA,IAC3B,CAAC;AAAA,EACH;AAEA,kBAAgB,gBAAgB;AAC9B,WAAO,MAAM;AACX,YAAM,OAAO,MAAM,KAAK;AAExB,UAAI,SAAS,QAAW;AACtB;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,iBAAe,OAA+C;AAC5D,UAAM,QAAQ,MAAM,KAAK;AACzB,WAAO,EAAE,MAAM,QAAQ,MAAM;AAAA,EAC/B;AAEA,QAAM,SAAoB;AAAA,IACxB;AAAA,IACA;AAAA,IACA,OAAO,MAAM;AACX,eAAS;AAGT,YAAM,iBAAiB,aAAa,OAAO,GAAG,aAAa,MAAM;AACjE,iBAAW,WAAW,gBAAgB;AACpC,gBAAQ,MAAS;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAwB;AAAA,IAC5B;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,MAAM;AAAA,IAChB,CAAC,OAAO,aAAa,GAAG;AAAA,EAC1B;AAEA,SAAO,CAAC,QAAQ,QAAQ;AAC1B;","names":[]}
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  parse: () => parse,
  parseFromStream: () => parseFromStream,
  stringify: () => stringify,
  stringifyAsync: () => stringifyAsync,
  stringifyToStream: () => stringifyToStream
});
module.exports = __toCommonJS(src_exports);

// src/trackingPromise.ts
var TRACKING_PROMISE_SYMBOL = Symbol("TRACKING_PROMISE_SYMBOL");
function trackPromise(id, promise) {
  const tracking = Object.assign(promise, {
    id,
    status: { state: "pending" },
    [TRACKING_PROMISE_SYMBOL]: true
  });
  tracking.then((data) => {
    tracking.status = {
      state: "resolved",
      data
    };
  }).catch((error) => {
    tracking.status = {
      state: "rejected",
      error
    };
  });
  return tracking;
}
function isTrackingPromise(value) {
  return value != null && typeof value.id === "number" && typeof value.status === "object" && value[TRACKING_PROMISE_SYMBOL] === true && value instanceof Promise;
}
async function forEachPromise(promises, callbacks) {
  const { onResolved, onRejected } = callbacks;
  const pendingPromises = [];
  for (const p of promises) {
    let resolving = p.then((data) => {
      onResolved({ id: p.id, data });
    });
    if (onRejected) {
      resolving = resolving.catch((error) => {
        onRejected({ id: p.id, error });
      });
    }
    pendingPromises.push(resolving);
  }
  await Promise.all(pendingPromises);
}

// src/utils.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function bufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64ToBuffer(base64String, Constructor) {
  const binaryString = atob(base64String);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return new Constructor(bytes.buffer);
}

// src/tag.ts
var TYPED_ARRAY_TAGS = [
  "A" /* ArrayBuffer */,
  "C" /* Int8Array */,
  "c" /* Uint8Array */,
  "U" /* Uint8ClampedArray */,
  "P" /* Int16Array */,
  "p" /* Uint16Array */,
  "L" /* Int32Array */,
  "l" /* Uint32Array */,
  "F" /* Float32Array */,
  "d" /* Float64Array */,
  "N" /* BigInt64Array */,
  "m" /* BigUint64Array */,
  "V" /* DataView */
];
function isTypedArrayTag(tag) {
  return TYPED_ARRAY_TAGS.includes(tag);
}

// src/trackingAsyncIterable.ts
var TRACKING_ASYNC_ITERABLE_SYMBOL = Symbol("TRACKING_ASYNC_ITERABLE_SYMBOL");
function trackAsyncIterable(id, asyncIterator, context) {
  return Object.assign(asyncIterator, {
    id,
    context,
    [TRACKING_ASYNC_ITERABLE_SYMBOL]: true
  });
}
function isTrackingAsyncIterable(value) {
  return value != null && typeof value.id === "number" && typeof value[Symbol.asyncIterator] === "function" && value[TRACKING_ASYNC_ITERABLE_SYMBOL] === true;
}

// src/json/stringify.ts
function stringify(value, replacer, space) {
  const { output, pendingPromises, pendingIterators } = internal_serialize(
    value,
    {
      replacer,
      space
    }
  );
  if (pendingPromises.length > 0) {
    throw new Error("Serialiation result have pending promises");
  }
  if (pendingIterators.length > 0) {
    throw new Error("Serialiation result have pending async iterators");
  }
  return JSON.stringify(output, null, space);
}
async function stringifyAsync(value, replacer, space) {
  const result = internal_serialize(value, {
    replacer,
    space
  });
  await Promise.all(result.pendingPromises);
  const iteratorPromises = result.pendingIterators.map(async (gen) => {
    for await (const _ of gen) {
    }
  });
  await Promise.all(iteratorPromises);
  return JSON.stringify(result.output, null, space);
}
function stringifyToStream(value, replacer, space) {
  const result = internal_serialize(value, {
    replacer,
    space
  });
  return new ReadableStream({
    async start(controller) {
      const json = JSON.stringify(result.output, null, space);
      const pendingIteratorsMap = /* @__PURE__ */ new Map();
      controller.enqueue(`${json}

`);
      await forEachPromise(result.pendingPromises, {
        async onResolved({ data, id }) {
          const resolved = trackPromise(id, Promise.resolve(data));
          const serializedPromise = internal_serialize(resolved, {
            replacer,
            initialID: id
          });
          await Promise.all(serializedPromise.pendingPromises);
          const promiseJson = JSON.stringify(
            serializedPromise.output,
            null,
            space
          );
          if (serializedPromise.pendingIterators.length > 0) {
            for (const gen of serializedPromise.pendingIterators) {
              pendingIteratorsMap.set(gen.id, gen);
            }
          }
          controller.enqueue(`${promiseJson}

`);
        }
      });
      if (result.pendingIterators.length > 0) {
        for (const gen of result.pendingIterators) {
          pendingIteratorsMap.set(gen.id, gen);
        }
      }
      const pendingIterators = Array.from(pendingIteratorsMap.values());
      const resolveIterators = pendingIterators.map(async (iter) => {
        for await (const item of iter) {
          const asyncIteratorOutput = unsafe_writeOutput(
            "#" /* AsyncIterator */,
            iter.id,
            [item]
          );
          const genJson = JSON.stringify(asyncIteratorOutput, null, space);
          controller.enqueue(`${genJson}

`);
        }
      });
      await Promise.all(resolveIterators);
      controller.close();
    }
  });
}
function internal_serialize(value, opts) {
  const { replacer, space, initialID = 1 } = opts;
  const writtenValues = /* @__PURE__ */ new Map();
  const pendingPromisesMap = /* @__PURE__ */ new Map();
  const pendingIteratorsMap = /* @__PURE__ */ new Map();
  const output = [];
  let id = initialID;
  const nextId = () => {
    return id++;
  };
  const checkWrittenValues = () => {
    for (const [id2, value2] of writtenValues) {
      output[id2] = value2;
    }
  };
  const context = {
    output,
    writtenValues,
    pendingPromisesMap,
    pendingIteratorsMap,
    space,
    nextId,
    encodeValue,
    checkWrittenValues
  };
  function encodeValue(input) {
    if (replacer) {
      const serialized = replacer(input, context);
      if (serialized !== void 0) {
        return serialized;
      }
    }
    switch (typeof input) {
      case "string":
        return `$$${input}`;
      case "boolean":
        return input;
      case "number":
        return serializeNumber(input);
      case "symbol":
        return serializeSymbol(input);
      case "undefined":
        return "$undefined";
      case "bigint":
        return serializeBigInt(input);
      case "object": {
        if (input === null) {
          return null;
        } else if (input instanceof Date) {
          return serializeDate(input);
        } else if (input instanceof Map) {
          return serializeMap(input, context);
        } else if (input instanceof Set) {
          return serializeSet(input, context);
        } else if (Array.isArray(input)) {
          return serializeArray(input, context);
        } else if (isPlainObject(input)) {
          return serializePlainObject(input, context);
        } else if (input instanceof Promise) {
          return serializePromise(input, context);
        } else if (isAsyncIterable(input)) {
          return serializeAsyncIterable(input, context);
        } else if (input instanceof ArrayBuffer) {
          return serializeArrayBuffer(input, context);
        } else if (input instanceof Int8Array) {
          return serializeTypedArray("C" /* Int8Array */, input, context);
        } else if (input instanceof Uint8Array) {
          return serializeTypedArray("c" /* Uint8Array */, input, context);
        } else if (input instanceof Uint8ClampedArray) {
          return serializeTypedArray("U" /* Uint8ClampedArray */, input, context);
        } else if (input instanceof Int16Array) {
          return serializeTypedArray("P" /* Int16Array */, input, context);
        } else if (input instanceof Uint16Array) {
          return serializeTypedArray("p" /* Uint16Array */, input, context);
        } else if (input instanceof Int32Array) {
          return serializeTypedArray("L" /* Int32Array */, input, context);
        } else if (input instanceof Uint32Array) {
          return serializeTypedArray("l" /* Uint32Array */, input, context);
        } else if (input instanceof Float32Array) {
          return serializeTypedArray("F" /* Float32Array */, input, context);
        } else if (input instanceof Float64Array) {
          return serializeTypedArray("d" /* Float64Array */, input, context);
        } else if (input instanceof BigInt64Array) {
          return serializeTypedArray("N" /* BigInt64Array */, input, context);
        } else if (input instanceof BigUint64Array) {
          return serializeTypedArray("m" /* BigUint64Array */, input, context);
        } else if (input instanceof DataView) {
          return serializeTypedArray("V" /* DataView */, input, context);
        } else {
          throw new Error(
            `Unable to serialize value: ${JSON.stringify(input)}`
          );
        }
      }
      case "function": {
        throw new Error("Functions cannot be serialized");
      }
      default:
        throw new Error(
          `Unreachable. Reaching this code should be considered a bug`
        );
    }
  }
  const baseValue = encodeValue(value);
  output[0] = baseValue;
  checkWrittenValues();
  return {
    output,
    get pendingPromises() {
      return Array.from(pendingPromisesMap.values());
    },
    get pendingIterators() {
      return Array.from(pendingIteratorsMap.values());
    }
  };
}
function serializeNumber(input) {
  if (Number.isFinite(input)) {
    if (input === 0 && 1 / input === -Infinity) {
      return serializeTagValue("-0" /* NegativeZero */);
    } else {
      return input;
    }
  } else {
    if (input === Infinity) {
      return serializeTagValue("Infinity" /* Infinity_ */);
    } else if (input === -Infinity) {
      return serializeTagValue("-Infinity" /* NegativeInfinity */);
    } else {
      return serializeTagValue("NaN" /* NaN_ */);
    }
  }
}
function serializeSymbol(input) {
  return serializeTagValue("S" /* Symbol */, input.description);
}
function serializeBigInt(input) {
  return serializeTagValue("n" /* BigInt */, String(input));
}
function serializeDate(input) {
  return serializeTagValue("D" /* Date */, input.toJSON());
}
function serializeArray(input, context) {
  const items = [];
  for (const val of input) {
    items.push(context.encodeValue(val));
  }
  return items;
}
function serializeSet(input, context) {
  const { writtenValues: referencesMap } = context;
  const items = [];
  for (const val of input) {
    items.push(context.encodeValue(val));
  }
  const id = context.nextId();
  referencesMap.set(id, items);
  return serializeTagValue("W" /* Set */, id);
}
function serializeMap(input, context) {
  const { writtenValues: referencesMap } = context;
  const items = [];
  for (const [k, v] of input) {
    const encodedKey = context.encodeValue(k);
    const encodedValue = context.encodeValue(v);
    items.push([encodedKey, encodedValue]);
  }
  const id = context.nextId();
  referencesMap.set(id, items);
  return serializeTagValue("Q" /* Map */, id);
}
function serializePlainObject(input, context) {
  const obj = {};
  for (const [key, value] of Object.entries(input)) {
    obj[key] = context.encodeValue(value);
  }
  return obj;
}
function serializePromise(input, context) {
  const id = context.nextId();
  const resolvingPromise = input.then((value) => {
    const ret = context.encodeValue(value);
    context.writtenValues.set(id, ret);
    context.checkWrittenValues();
    return value;
  });
  const trackingPromise = trackPromise(id, resolvingPromise);
  context.pendingPromisesMap.set(id, trackingPromise);
  return serializeTagValue("@" /* Promise */, id);
}
function serializeArrayBuffer(input, context) {
  return serializeTypedArray("A" /* ArrayBuffer */, new Uint8Array(input), context);
}
function serializeTypedArray(tag, input, context) {
  const id = context.nextId();
  const buffer = bufferToBase64(input.buffer);
  context.writtenValues.set(id, buffer);
  return serializeTagValue(tag, id);
}
function serializeAsyncIterable(input, context) {
  const id = context.nextId();
  async function* resolveAsyncIterable(iter) {
    for await (const item of iter) {
      if (isAsyncIterable(item)) {
        yield* resolveAsyncIterable(item);
      } else {
        yield item;
      }
    }
  }
  const generator = async function* () {
    for await (const item of resolveAsyncIterable(input)) {
      const ret = context.encodeValue(item);
      const items2 = [...context.output[id] || [], ret];
      context.writtenValues.set(id, items2);
      context.checkWrittenValues();
      yield ret;
    }
    const items = [...context.output[id] || [], "done"];
    context.writtenValues.set(id, items);
    context.checkWrittenValues();
    yield "done";
  }();
  const tracked = trackAsyncIterable(id, generator);
  context.pendingIteratorsMap.set(id, tracked);
  return serializeTagValue("#" /* AsyncIterator */, id);
}
function serializeTagValue(tag, value) {
  return value ? `$${tag}${value}` : `$${tag}`;
}
function unsafe_writeOutput(tag, id, value) {
  const output = [serializeTagValue(tag, id)];
  output[id] = value;
  return output;
}
function isAsyncIterable(value) {
  return value != null && typeof value[Symbol.asyncIterator] === "function";
}

// src/channel.ts
function createChannel(options) {
  const { id } = options;
  const queue = [];
  const resolveQueue = [];
  let closed = false;
  function send(value) {
    if (closed) {
      throw new Error("Channel was closed");
    }
    const promise = value instanceof Promise ? value : Promise.resolve(value);
    const resolve = resolveQueue.shift();
    if (resolve) {
      resolve(promise);
    } else {
      queue.push(promise);
    }
  }
  async function recv() {
    if (closed && queue.length === 0) {
      return void 0;
    }
    const promise = queue.shift();
    if (promise) {
      return promise;
    }
    return new Promise((resolve) => {
      resolveQueue.push(resolve);
    });
  }
  async function* asyncIterator() {
    while (true) {
      const item = await recv();
      if (item === void 0) {
        break;
      }
      yield item;
    }
  }
  async function next() {
    const value = await recv();
    return { done: closed, value };
  }
  const sender = {
    id,
    send,
    close: () => {
      closed = true;
      const pendingResolve = resolveQueue.splice(0, resolveQueue.length);
      for (const resolve of pendingResolve) {
        resolve(void 0);
      }
    }
  };
  const receiver = {
    id,
    recv,
    next,
    isClosed: () => closed,
    [Symbol.asyncIterator]: asyncIterator
  };
  return [sender, receiver];
}

// src/deferredPromise.ts
function deferredPromise() {
  let resolve = (_value) => {
  };
  let reject = (_reason) => {
  };
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return {
    promise,
    resolve,
    reject
  };
}

// src/json/parse.ts
function parse(value, reviver) {
  const result = internal_parseValue(value, { reviver });
  return result.data;
}
async function parseFromStream(stream, reviver) {
  const reader = internal_parseFromStream(stream, reviver).getReader();
  let resolved = false;
  const deferred = deferredPromise();
  void Promise.resolve().then(async () => {
    const promises = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done || value === void 0) {
        break;
      }
      if (!resolved) {
        resolved = true;
        deferred.resolve(value);
      }
      if (value instanceof Promise) {
        promises.push(value);
      }
    }
    if (!resolved) {
      deferred.reject(new Error("Unable to find resolved value"));
    }
    await Promise.all(promises);
  });
  return deferred.promise;
}
function internal_parseFromStream(stream, reviver) {
  const promisesMap = /* @__PURE__ */ new Map();
  const channelsMap = /* @__PURE__ */ new Map();
  const reader = stream.getReader();
  return new ReadableStream({
    async start(controller) {
      async function processChunk(jsonChunk) {
        const { data, pendingPromises, pendingChannels } = internal_parseValue(
          jsonChunk,
          {
            deferPromises: true,
            reviver
          }
        );
        controller.enqueue(data);
        {
          for (const [id, deferred] of pendingPromises.entries()) {
            promisesMap.set(id, deferred);
          }
          if (isTrackingPromise(data)) {
            const deferred = promisesMap.get(data.id);
            if (!deferred) {
              throw new Error(`Promise with id: '${data.id}' was not found`);
            }
            try {
              const returnValue = await data;
              deferred.resolve(returnValue);
            } catch (err) {
              deferred.reject(err);
            }
          }
        }
        {
          if (pendingChannels.size > 0) {
            for (const [id, channelSender] of pendingChannels.entries()) {
              channelsMap.set(id, channelSender);
            }
          }
          if (isTrackingAsyncIterable(data)) {
            const sender = channelsMap.get(data.id);
            if (!sender) {
              throw new Error(
                `AsyncIterator sender with id '${data.id}' was not found`
              );
            }
            const isDone = data.context === "done";
            for await (const item of data) {
              sender.send(item);
            }
            if (isDone) {
              sender.close();
            }
          }
        }
      }
      while (true) {
        const { done, value: raw } = await reader.read();
        if (done || raw === void 0) {
          break;
        }
        const chunks = raw.split("\n\n").filter(Boolean);
        if (chunks.length > 1) {
          const promises = chunks.map(processChunk);
          await Promise.all(promises);
        } else {
          await processChunk(chunks[0]);
        }
      }
      controller.close();
    }
  });
}
function internal_parseValue(value, opts) {
  const { deferPromises = false, reviver } = opts || {};
  const pendingPromises = /* @__PURE__ */ new Map();
  const pendingChannels = /* @__PURE__ */ new Map();
  const { references, base } = function() {
    try {
      const references2 = JSON.parse(value);
      return { references: references2, base: references2[0] };
    } catch {
      throw new Error(`Failed to parse base value: ${value}`);
    }
  }();
  const deserizalizeValue = (input) => {
    if (reviver) {
      const ret = reviver(input);
      if (ret !== void 0) {
        return ret;
      }
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input;
      case "string": {
        if (input[0] === "$") {
          const maybeTag = input.slice(1);
          switch (true) {
            case maybeTag[0] === "$" /* String */: {
              return input.slice(2);
            }
            case maybeTag[0] === "S" /* Symbol */: {
              return Symbol.for(input.slice(2));
            }
            case maybeTag[0] === "D" /* Date */: {
              return new Date(input.slice(2));
            }
            case maybeTag[0] === "n" /* BigInt */: {
              return BigInt(input.slice(2));
            }
            case maybeTag === "undefined" /* Undefined */: {
              return void 0;
            }
            case maybeTag === "Infinity" /* Infinity_ */: {
              return Infinity;
            }
            case maybeTag === "-Infinity" /* NegativeInfinity */: {
              return -Infinity;
            }
            case maybeTag === "-0" /* NegativeZero */: {
              return -0;
            }
            case maybeTag === "NaN" /* NaN_ */: {
              return NaN;
            }
            case maybeTag[0] === "W" /* Set */: {
              const id = parseTagId(input.slice(2));
              const set = /* @__PURE__ */ new Set();
              try {
                const values = references[id];
                if (values) {
                  if (Array.isArray(values)) {
                    for (const item of values) {
                      set.add(deserizalizeValue(item));
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return set;
            }
            case maybeTag[0] === "Q" /* Map */: {
              const id = parseTagId(input.slice(2));
              const map = /* @__PURE__ */ new Map();
              try {
                const values = references[id];
                if (values) {
                  if (Array.isArray(values)) {
                    for (const [key, value2] of values) {
                      const decodedKey = deserizalizeValue(key);
                      const decodedValue = deserizalizeValue(value2);
                      map.set(decodedKey, decodedValue);
                    }
                  }
                }
              } catch (err) {
                console.error(err);
              }
              return map;
            }
            case maybeTag[0] === "@" /* Promise */: {
              const id = parseTagId(input.slice(2));
              const rawValue = references[id];
              if (rawValue === void 0) {
                if (deferPromises) {
                  const deferred = deferredPromise();
                  pendingPromises.set(id, deferred);
                  return deferred.promise;
                }
                throw new Error("Failed to find promise resolved value");
              }
              try {
                const resolvedValue = deserizalizeValue(rawValue);
                return trackPromise(id, Promise.resolve(resolvedValue));
              } catch {
                throw new Error("Unable to resolve promise value");
              }
            }
            case maybeTag[0] === "#" /* AsyncIterator */: {
              const id = parseTagId(input.slice(2));
              const asyncIteratorValues = references[id];
              if (!asyncIteratorValues) {
                const [sender, receiver] = createChannel({ id });
                pendingChannels.set(id, sender);
                return receiver;
              }
              if (Array.isArray(asyncIteratorValues)) {
                const length = asyncIteratorValues.length - 1;
                const isDone = asyncIteratorValues[length] === "done";
                const values = isDone ? asyncIteratorValues.slice(0, -1) : asyncIteratorValues;
                const generator = async function* () {
                  for (const item of values) {
                    const resolvedValue = deserizalizeValue(item);
                    yield resolvedValue;
                  }
                }();
                const trackedAsyncIterator = trackAsyncIterable(
                  id,
                  generator,
                  isDone ? "done" : void 0
                );
                return trackedAsyncIterator;
              } else {
                throw new Error(
                  "Failed to parse async iterator, expected array of values"
                );
              }
            }
            case isTypedArrayTag(maybeTag[0]): {
              return deserializeBuffer(maybeTag[0], input, {
                references
              });
            }
            default:
              throw new Error(`Unknown reference value: ${input}`);
          }
        } else {
          throw new Error(`Invalid reference value: ${input}`);
        }
      }
      case "object": {
        if (input === null) {
          return null;
        } else if (Array.isArray(input)) {
          const arr = [];
          for (const item of input) {
            arr.push(deserizalizeValue(item));
          }
          return arr;
        } else if (isPlainObject(input)) {
          const obj = {};
          for (const [key, value2] of Object.entries(input)) {
            obj[key] = deserizalizeValue(value2);
          }
          return obj;
        } else {
          throw new Error(`Invalid object value: ${JSON.stringify(input)}`);
        }
      }
      default:
        throw new Error(`Invalid value: ${input}`);
    }
  };
  const data = deserizalizeValue(base);
  return { data, pendingPromises, pendingChannels };
}
function deserializeBuffer(tag, input, context) {
  const getBufferData = () => {
    const id = parseTagId(input.slice(2));
    const data = context.references[id];
    if (!data) {
      throw new Error(`Unable to get '${input}' buffer data`);
    }
    return String(data);
  };
  switch (tag) {
    case "A" /* ArrayBuffer */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return bytes.buffer;
    }
    case "C" /* Int8Array */:
      return base64ToBuffer(getBufferData(), Int8Array);
    case "c" /* Uint8Array */:
      return base64ToBuffer(getBufferData(), Uint8Array);
    case "U" /* Uint8ClampedArray */:
      return base64ToBuffer(getBufferData(), Uint8ClampedArray);
    case "P" /* Int16Array */:
      return base64ToBuffer(getBufferData(), Int16Array);
    case "p" /* Uint16Array */:
      return base64ToBuffer(getBufferData(), Uint16Array);
    case "L" /* Int32Array */:
      return base64ToBuffer(getBufferData(), Int32Array);
    case "l" /* Uint32Array */:
      return base64ToBuffer(getBufferData(), Uint32Array);
    case "F" /* Float32Array */:
      return base64ToBuffer(getBufferData(), Float32Array);
    case "d" /* Float64Array */:
      return base64ToBuffer(getBufferData(), Float64Array);
    case "N" /* BigInt64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigInt64Array(bytes.buffer);
    }
    case "m" /* BigUint64Array */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new BigUint64Array(bytes.buffer);
    }
    case "V" /* DataView */: {
      const bytes = base64ToBuffer(getBufferData(), Uint8Array);
      return new DataView(bytes.buffer);
    }
    default:
      throw new Error(`Unknown typed array buffer: ${input}`);
  }
}
function parseTagId(input) {
  const id = parseInt(input);
  if (!Number.isFinite(id) || Number.isNaN(id)) {
    throw new Error(`Invalid tag id: '${input}'`);
  }
  return id;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  parse,
  parseFromStream,
  stringify,
  stringifyAsync,
  stringifyToStream
});
//# sourceMappingURL=index.cjs.map